蓝桥杯不支持C++11

**所以**

```c++
to_string,auto,unordered_set,unordered_map不可以用
```

# dev

格式化代码`ctrl + shift + a`

`ctrl + `左右键使光标移动一个单词距离

`shirt +`左右键可以选中字符

# c++

## 字符串或者数组转换为数字

**思路**：模拟即可

### 字符串转换为数字板子

```c++
int fun(string &s)
{
	int res=0;
	for(int i=s.size()-1,j=1;i>=0;i--,j*=10)
	res=res+(s[i]-'0')*j;
	return res;
}
```

### 数组中的数转换为数字

```c++
//整型数组
int a[5]={1,2,3,4,5},n=5;
int fun()
{
    int res=0;
    for(int i=n-1,j=1;i>=0;i--,j*=10){
		res=res+a[i]*j;
    }
    return res;
}
//char 数组
char a[5]={1,2,3,4,5};
int n=5;
int fun()
{
    int res=0;
    for(int i=n-1,j=1;i>=0;i--,j*=10){
		res=res+(a[i]-'0')*j;
    }
    return res;
}
```

## &运算

a&b并不会增加其最大值，所以

题意：对于一个序列选择0个或者多个进行&运算，求其中的最大值。

思路：其实遍历序列找到最大值即可，选择0个是避免其中最大数他没有相等的。

# 模板

```c++
int dir[8][2]={{-2,-1},{-1,2},{2,1},{-1,-2},{-2,1},{1,2},{2,-1},{1,-2}};//马走日 (马的方向)
```

## 万能头文件

```c++
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e5+5;
typedef long long ll;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int _;
    cin>>_;
    while(_--)
    {
        
    }
	return 0;
 } 
```



## c++模板

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<utility>
#include<vector>
#include<set>
#include<stack>
#include<queue>
#define repr(i,n) for(int i=1;i<=n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define pb push_back//vector,deque
#define pi pair<int>
#define ll long long 
#define INF 0x3f3f3f3f
#define scd(n) scanf("%d",&n)
#define scf(n) scanf("%f",&n)
#define scc(n) scanf("%c",&n)
#define scs(n) scanf("%s",n)
#define prd(n) printf("%d",n)
#define prf(n) printf("%f",n)
#define prc(n) printf("%c",n)
#define prs(n) printf("%s",n)
using namespace std;
const int N=1e5+5;
int main()
{
	int _;
    cin>>_;
    while(_--)
    {
        
    }
	return 0;
 } 
```

## 整除分块



```c++
//给整数n，求∑i=1,n[n/i],[x]为向下取整
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
typedef long long ll;
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    	ll ans=0;
        for(int l=1,r;l<=n;l=r+1)
        {
            r=n/(n/l);
            ans+=(r-l+1)*(n/l);
         }
	return 0;
 } 
```

# 函数

## log

```c++
在math库中
   log2()	以2为底
   loh10()	以10为底
    log()	默认以e为底
```

## printf

```c++
//以十六进制赋值
int x;
x=0xABCDEF;
printf("%d",x);//输出x的十进制
```

## sprintf

```c++
char res[20]
sprintf(res,"%04d-%02d-%02d",year,month,day)
    //将数字转换为字符串存入res
```

## sscanf

```c++
string data="20th Oct 2052"
sscanf(data.c_str(),"%d%*s %s %d",&day,months,&year)
    //c_str将string转化为char *类型与c语言兼容，然后就是格式化，%*s把多余的th去掉不占位
```

## getline

```c++
//读取一行数据，但是最后的换行符不会吃掉	
	string s;
	while(getline(cin,s))//getline(cin,s)s需是string类型
	{
		reverse(s.begin(),s.end());
		cout<<s<<"\n";
	}
//速度较慢
```

## cin.getline

```c++
char s[100];
while(cin.getline(s,100,'\n'))//第三个参数是分隔符，可以不写，默认换行符
{
	cout<<s<<"\n";
}
//速度较快，必须是cahr *
```

## find

1. 对于vector的查找

```c++
/*参数：
	find(迭代器起点，终点，key)
	同时要引入头文件algorithm
*/
#include<bits/stdc++.h>
using namespace std;
map<int,int>mp; 
int main()
{
   vector<int>v;
   for(int i=0;i<10;i++)v.push_back(i);
   if(find(v.begin(),v.end(),10)!=v.end())cout<<"YES";
   else cout<<"NO";
    return 0;
}

```

2. map的查找（unordered_map同样适用）

```c++
/*
	mp.find(key),find()函数返回一个迭代器指向键值为key的元素，否则返回end迭代器
*/
#include<bits/stdc++.h>
using namespace std;
map<int,int>mp; 
int main()
{
    mp[1]=1;mp[2]=2;mp[3]=3;
    auto it=mp.find(3);
    if(it!=mp.end())cout<<it->second<<"\n";
    else cout<<"没找到";
    return 0;
}

```

3. set的查找

```c++
#include<bits/stdc++.h>
using namespace std;
unordered_map<int,int>mp; 
int main()
{
    set<int>s;
    for(int i=0;i<10;i++)s.insert(i);
    auto it=s.find(5);
    if(it!=s.end())cout<<*it<<"\n";
    else cout<<"NO";
    return 0;
}

```

4. string查找

在字符串中查找字符

```c++
str.find(tt,index)
    //返回tt在str字符串中第一次出现的位置，从index下标开始查找。没找到返回string::npos(-1),其中tt支持是string或者char *
    str.find(tt,index,length)
    //返回str在字符串中第一次出现的位置（从index开始查找，长度为length）。如果没找到就返回string::npos
    str.find(c,index)
    //返回字符c在字符串中第一次出现的位置（从index开始查找）。如果没找到就返回string::npos 
```

## isdigit

```c++
/*	头文件 #include<ctype.h>
	判断字符是否是数字
*/
char c;
cin>>c;
if(isdigit)cout<<"Yes";
else cout<<"No";
```



## string类

```c++
当定义string s;
这个时候并没有为s申请内存空间，所以你通过下标赋值，然后cout<<s会出错。
    可以直接定义string s(len,'0')默认给他len个长度的'0'
```

### substr

返回某个子字符串

```c++
T=str.substr(index,num)
    //substr()返回本字符串的一个子串，从index开始，长num个字符,当不指定num时，默认直接返回从index开始后剩余的字符串
```



```c++
string str;
str.erase(str.size()-k)//删除后k个字符串
    str.erase(position,len)//删除从position位置起的len个长度
    //例如1234567890
    str.erase(5,3)//输出1234590
    str.erase(position)//删除从position位置开始的后面所有元素    
    
```

### to_string

**c++11里边的不支持C++11的用了会编译错误**

```c++
功能：将数值转换为字符串，返回对应的字符串（只能从数字转换为string）
	string s;
	int a=15;
	s=to_string(1+5);
	cout<<s<<"\n";
	s=to_string(a);
	cout<<s<<"\n";
	return 0;

```

### c_str

```c++
/*
将string类型转换成char *。
这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式
*/

	string s;
	s="123";
	printf("%s\n",s.c_str());//用printf不能直接输出string类型必须转换成c语言能识别的类型
//将string类型转换为char *
char c[20]; 
string s="1234"; 
strcpy(c,s.c_str());
printf("%s\n",c);
sscanf(s.c_str(),"%s",c);
printf("%s\n",c);
```

## lower_bound和upper_bound

头文件`#include<algorithm>`

lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 **第一个** 出现的位置。

upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 **最后一个** 出现的位置。(最后一个出现的后边的后边一个位置)

binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个**bool值**。

例题：[数的范围](https://www.acwing.com/problem/content/791/)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int a[N];
int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<k;i++){
        int x;
        cin>>x;
        int l=lower_bound(a,a+n,x)-a;
        int r=upper_bound(a,a+n,x)-a;
        if(l==r)
            cout<<"-1 -1\n";
        else
            cout<<l<<' '<<r-1<<'\n';
    }
    return 0;
}
```

# STL

## vector

### 利用algroithm中的find函数进行查找

```c++
/*参数：
	find(迭代器起点，终点，key)
	同时要引入头文件algorithm
*/
#include<bits/stdc++.h>
using namespace std;
int main()
{
   vector<int>v;
   for(int i=0;i<10;i++)v.push_back(i);
   if(find(v.begin(),v.end(),10)!=v.end())cout<<"YES";
   else cout<<"NO";
    return 0;
}

```

### 利用algorithm中的count函数查找

```c++
/*
	count(迭代器起点，终点，查找的值)
	返回查找的个数
*/
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main() {
	vector<int>a;
	for(int i=1;i<=10;i++)
	a.push_back(i);
	a.push_back(10);
	cout<<count(a.begin(),a.end(),10);
	return 0;
}
```



## 优先队列

> 优先队列（priority_queue）#include<queue>

```c++
//定义：priority_queue<Type, Container, Functional>
//Type即数据类型，Container：容器类型，Functional：比较方式

//升序队列，小顶堆
priority_queue <int,vector<int>,greater<int> > q;

//降序队列，大顶堆
priority_queue <int,vector<int>,less<int> >q;

//默认是大顶堆，降序排序
priority<int>q
//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
  
    q.top()//弹出第一个
    
```

## 迭代器

```c++
//例如想要用vector的迭代器
vector<int>::iterator it;
```

## map

map的插入方式

1. 使用insert函数插入pair数据

```c++
/*
	insert插入过程中他不会覆盖掉value值，例如
	key=2，value=3，第三个是改成5，而这里不会改。
*/
#include<bits/stdc++.h>
 using namespace std;
 const int N=1e5;
 typedef long long ll;
 int main()
 {
     map<int,int>mp;
     mp.insert(pair<int,int>(1,2));
     mp.insert(pair<int,int>(2,3));
     mp.insert(pair<int,int>(2,5));
     for(auto x:mp){
     	cout<<x.first<<' '<<x.second<<'\n';
	 }
     return 0;
 }
```

2. 数组形式插入key和value

```c++
/*
	这里直接用数组形式，插入数据。
	同时他可以修改已经存在的key中的value
	例如key-2已存在，但是后边又修改了value-5
*/
#include<bits/stdc++.h>
 using namespace std;
 const int N=1e5;
 typedef long long ll;
 int main()
 {
     map<int,int>mp;
     mp[1]=2;
     mp[2]=3;
     mp[2]=5;
     for(auto x:mp){
     	cout<<x.first<<' '<<x.second<<'\n';
	 }
     return 0;
 }
```

## pair

```c++
#include<utility>//老忘记他的头文件....
pair<T1, T2> p1;            
//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。
pair<T1, T2> p1(v1, v2);    
//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。
make_pair(v1, v2);          
// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。
p1 < p2;                    
// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first < p2.first 或者 !(p2.first < p1.first) && (p1.second < p2.second) 则返回true。
p1 == p2；                 
// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。
p1.first;                   
// 返回对象p1中名为first的公有数据成员
p1.second;                 
// 返回对象p1中名为second的公有数据成员
```



# 基本算法

## 离散化和差分

题意：给你n条线段（每个线段覆盖[l,r]区间），	求有多少个点被覆盖1次，2次...n次[原题链接](https://codeforces.com/contest/1000/problem/C)

> 用差分处理区间修改，然后求其前缀和。

```c++
typedef long long ll;
const int N=2e5+5;
map<ll,ll>::iterator it;
ll ans[N];
int main()
{
	map<ll,ll>mp;
	int n;
	cin>>n;
	ll l,r;
	for(int i=1;i<=n;i++){
		cin>>l>>r;
		mp[l]++;
		mp[r+1]--;
	}
	ll last=0,cnt=0;
	cout<<mp.size()<<'\n';
	for(it=mp.begin();it!=mp.end();it++){
		ans[cnt]+=it->first-last;
		last=it->first;
		cnt+=it->second;
	}
	for(int i=1;i<=n;i++)cout<<ans[i]<<' ';
  return 0;
}
```

牛牛与比赛颁奖[原题链接](https://ac.nowcoder.com/acm/contest/9982/G)

```c++
map<int,int>mp;
int cot[N];//通过i题的队伍人数 
int main()
{
	int n,m;
	cin>>n>>m;
	int l,r;
	for(int i=0;i<m;i++){
		cin>>l>>r;
		mp[l]++;
		mp[r+1]--;
	}
	int linej=0,liney=0,linet=0,j=ceil(1.0*n/10),y=ceil(1.0*n/4),t=ceil(1.0*n/2);
	int last=1,cnt=0,maxx=0;
	for(auto it:mp){
		cot[cnt]+=it.first-last;
		last=it.first;
		cnt+=it.second;
		maxx=max(maxx,cnt);
	}
	//cout<<j<<' '<<y<<' '<<t<<'\n';
	for(int i=maxx;i>=0;i--){
		cot[i]+=cot[i+1];
		if(cot[i]>=j&&!linej)linej=max(1,i);
		if(cot[i]>=y&&!liney)liney=max(1,i);
		if(cot[i]>=t&&!linet)linet=max(1,i);
		//cout<<cot[i]<<' ';
	}
	//cout<<'\n';
	//cout<<linej<<' '<<liney<<' '<<linet<<'\n';
	cout<<cot[linej]<<' '<<cot[liney]-cot[linej]<<' '<<cot[linet]-cot[liney]<<'\n';
  return 0;
}
```

https://ac.nowcoder.com/acm/contest/5773/D

## 排序

### 快排

> 将序列分成左右两个区间，以一个元素为中间元素，一般是以第一个定为中间元素（但会被卡，高效的话定义中间元素（l+r>>1）为中间元素），然后从左往右找比中间元素大的，从右往左找比中间元素小的，两者交换位置。之后以中间元素为分割线左边都是比mid小的，右边都是比mid大的，实际上这已经实现了部分排序（只不过左右内部边没有排序）之后递归实现左右部分都排序，直到L>=R退出

```c++
//快排模板很多，这个模板基本最优了，不会被卡。
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e5+5;
int a[maxn],n;
void quick_sort(int l,int r)
{
    if(l>=r)return a[l];//结束
    int i=l-1,j=n+1,t=a[l+r>>1];//这里+1是因为下边的j--（不会越界）l+r>>1优化一下
    while(i<j)
    {
        do i++;while(a[i]<t);
        do j--;while(a[j]>t);
        if(i<j)swap(a[i],a[j]);
    }
        quick_sort(l,j);//j一定是在左区域的最后一个，所以j+1是右区域
        quick_sort(j+1,r);
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    quick_sort(0,n-1);
   for(int i=0;i<n;i++)
       printf("%d ",a[i]);
    return 0;
}
//快速排序的版本很多，一不小心很容易出错!
```

#### 经典例题

> 求第k小数？

```c++
//快排模板很多，这个模板基本最优了，不会被卡。
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e5+5;
int a[maxn];
void quick_sort(int l,int r,int k)
{
    if(l>=r)return ;//结束
    int i=l-1,r=n+1,t=a[l+r>>1];//这里+1是因为下边的j--（不会越界）l+r>>1优化一下
    while(i<j)
    {
        do i++;while(a[i]<t);
        do j--;while(a[j]>t);
        if(i<j)swap(a[i],a[j]);
    }
    if(j-l+1>=k)
     return quick_sort(l,j,k);//j一定是在左区域的最后一个，所以j+1是右区域
    if(j-l+1<k)
     return quick_sort(j+1,r,k-(i-l+1));
}
int main()
{
    int n,k;
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
   int ans= quick_sort(0,n-1,k);
   cout<<ans<<endl;
    return 0;
}
//快速排序的版本很多，一不小心很容易出错!
```

```c++
//求第k小数方法2
/*
nth_element(a,a+k-1,a+n)求第k小数，从0开始
头文件#include<algorithm>
功能排序第k小数其他还是无需状态，在数据特别多的时候效率很高
*/
```



### 归并排序

```c++
//yxc模板
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];//那里的=号在求逆序对时必须写上
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
```

#### 经典例题

>求逆序对数？

```c++
#include<iostream>
using namespace std;
typedef long long ll;
const int maxn=1000005;
ll a[maxn];
ll  Merge_sort(int l,int r)
{
	if(l>=r)return 0;
	int m=l+r>>1;
	ll res=0;
	res+=Merge_sort(l,m);
	res+=Merge_sort(m+1,r);
	
	int i=l,j=m+1,cnt=0;
	ll t[r-l+1];
	while(i<=m&&j<=r){
		if(a[i]<=a[j])//其实=应该放在前边,不能放在后边
		t[cnt++]=a[i++];
		else{
			res+=m-i+1;//此处是寻找逆序对个数，因为当if不满足说明后边所有的数都是比i到m这大的个数并且满组了逆序对，所以m-i+1
			t[cnt++]=a[j++];
		}
	}
	while(i<=m)t[cnt++]=a[i++];
	while(j<=r)t[cnt++]=a[j++];
	
	for(int i=l,j=0;j<cnt;i++,j++)
	a[i]=t[j];
	return res;
	
	
}
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
	cin>>a[i];
	cout<<Merge_sort(0,n-1)<<endl;
	
	return 0;
}
```

```c++
//[力扣的88.合并两个有序数组（更好理解归并排序）]https://leetcode-cn.com/problems/merge-sorted-array/
```

## 双指针

```c++
//[两数之和]https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/submissions/
```

## 前缀和：

### 一维前缀和

#### 前序

> 一维前缀和，顾名思义，就是 sum[i]=sum[1]+sum[2]+……sum[i]
>
> 适用于在O(n)的预处理后，可以在O(1)查询sum[l,r]=sum[r]-sum[l-1]
>
> 和暴力求区间和比起来，暴力的时间复杂度在n很大的时候就不行了

问题：询问区间和（a[i]~a[j]）

```c++
for(int i=1;i<=n;i++)cin>>a[i];
for(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
```

然后就可以在O(n)的时间循环

求a[i]~a[j]

```c++
sum[j]-sum[i-1]
```

#### 经典例题

友好搭档：给定一个主串H和一个模式串S，求在主串H中有多少个子串和模式串S等价---地址（[传送门](http://oj.hzjingma.com/contest/problem?id=96&pid=8)）

等价的定义：两个字符串按照字典排序后相同，则认为等价字符串

解析：前缀和的思想，开两个int a[26]，先统计模式串中各个字符的次数，然后枚举主串，以模式串长度为一个区间进行比较，两者的字符串中各个字符出现的次数相等，则等价，！注意每次枚举一个区间后要把前边的区间给删掉

具体做法：

```c++
int cnt_t[26],cnt_s[26];
for(int i=0;i<t.size();i++)//枚举主串
{
    cnt_t[t[i]-'a']++;
    if(i>=s.size())//从第一个区间结束后就要把前边的区间给删掉
        cnt_t[t[i-s.size()]-'a']--;
    if(judge())//直接写个判断两个子串是否相等的函数即可
        ans++;
}
//也可以用vector来写，更加方便，不用自己再写判断函数，具体做法如下：
vector<int>cnt_t(26),cnt_s(26);
for(int i=0;i<t.size();i++)
{
    cnt_t[t[i]-'a']++;
    if(i>=s.size())
        cnt_t[t[i-s.size()]-'a']--;
    if(cnt_t==cnt_s)ans++;//两个vector相等即容量相等，所处位置的元素相等
}

```

```c++
//完整ac算法
#include<iostream>
#include<vector>
#include<string>
using namespace std;
string s,h;
int ans;
vector<int>cnts(26),cntt(26);
int main()
{
	cin>>s>>h;
	for(int i=0;i<s.size();i++)//统计子串中每个字符的个数 
	cnts[s[i]-'a']++;
	for(int i=0;i<h.size();i++)
	{
		cntt[h[i]-'a']++;
		if(i>=s.size())
		cntt[h[i-s.size()]-'a']--;//只统计长度为lens区间的字符串个数 
		if(cnts==cntt)//相等说明2个vector具有相同的容量。所有位置的元素相等 
		ans++;
	}
	cout<<ans<<endl;
	return 0;
 } 
```

### 二维前缀和

> 在一维的基础上，画图更容易理解,dp[i] [j]代表从dp[1] [1]到dp[i] [j]所围成的矩阵之和，那么我们第一步就是先构造前缀和，dp[i] [j]=dp[i-1] [j]+dp[i] [j-1]-dp[i-1] [j-1] (通过第一张图很直观的能够看出来)
>
> 接下来就是对于询问，求dp[x1] [y1]和dp[x2] [y2]之间的区域求和，dp[x2] [y2]-dp[x1-1] [y2]-dp[x2] [y1-1]+dp[x1-1] [y1-1]

<img src="https://img-blog.csdn.net/20180921215152309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTkwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:25%;" />

<img src="https://img-blog.csdn.net/20180922161308238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTkwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:25%;" />



```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e3+5;
int e[maxn][maxn];
long long dp[maxn][maxn];
int main()
{
	int n,m,q;
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)//二维数组
	for(int j=1;j<=m;j++)
	scanf("%d",&e[i][j]);
	for(int i=1;i<=n;i++)//预处理
	{
		for(int j=1;j<=m;j++)
		dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+e[i][j];
	}
	int x2,y2,x1,y1;
	while(q--)//进行q次询问，询问两个点之间矩阵和
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		printf("%lld\n",dp[x2][y2]-dp[x1-1][y2]-dp[x2][y1-1]+dp[x1-1][y1-1]);
	}
	return 0;
 } 
```

#### 例题

[裸题](http://oj.hzjingma.com/p/39?view=classic)

### 前缀和的进阶

#### 进阶1

完美子串 来源：竟码蓝桥杯模拟赛 [传送门](http://oj.hzjingma.com/contest/problem?id=140&pid=8&_pjax=%23p0)

思路：

![image-20200510214009508](https://i.loli.net/2020/05/10/WQnN3xVYeTBrcvS.png)

> 思路1,2(1,2的实现难度逐渐递增，后边给出1,2实现过程)，很简单实现，重要的是思路3。对于完美子串，可以推出对于任意区间[i,j]都满足L大+R大=L小+R小，则推出R大-R小=L小-L大，所以我们从右端预处理以下，minx[i]代表从i到x的位置有多少个比x小的，maxx[i]代表从i到x有多少个比x大的，那么我们求出R大-R小 =j有多少个,然后在左端枚举L小-L大有多少个j即可

```c++
//思路3：
#include<iostream>
#include<map>
using namespace std;
const int N=1e5+5;
int a[N],ans,minx[N],maxx[N];
map<int,int>m;
int main()
{
	int n,x,t;
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]==x)t=i;//找到这个位置
	}
	for(int i=t;i<=n;i++)//右端点前缀和处理
	{
		if(a[i]<a[t])minx[i]++;
		else if(a[i]>a[t])maxx[i]++;
		minx[i]+=minx[i-1];
		maxx[i]+=maxx[i-1];
		m[maxx[i]-minx[i]]++;//这里就是我们要找的R大-R小得个数key（maxx[i]-minx[i]）代表上述思路的j
	}
	ans=m[0];//一开始在右端点就已经有满足的了，因为j=0,就代表大于和小于的个数相等
	for(int i=t-1;i>=1;i--)//枚举左端点，这里一定是从左端点末尾开始，因为要用前缀和处理，从小到大开始处理不了i到x的大于和小于个数
	{
		if(a[i]<a[t])minx[i]++;
		else if(a[i]>a[t])maxx[i]++;
		minx[i]+=minx[i+1];
		maxx[i]+=maxx[i+1];
		ans+=m[minx[i]-maxx[i]];//这里就是我们要找的L小-L大=j看有多少个和R大-R小=j相等而通过key就直接能找到相等的个数
	}
	printf("%d\n",ans);
	return 0;
}
/*思路1：暴力出奇迹，O(n^3)跑出30%数据
*/
#include<iostream>
using namespace std;
const int N=1e5+5;
int a[N],ans;
bool judge(int i,int j,int t)
{
	int minx=0,max=0;
	for(int k=i;k<=j;k++)
	{
		if(a[k]>a[t])
		max++;
		else if(a[k]<a[t])
		minx++;
	}
	return minx==max;
}
int main()
{
	int n,x,t;
	scanf("%d%d",&n,&x);
	for(int i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]==x)t=i;
	}
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		if(i<=t&&t<=j&&judge(i,j,t))
		ans++;
	}
	printf("%d\n",ans);
	return 0;
}
/*思路2：优美暴力，使用了前缀和思想，（提前预处理一下，处理过程如下）
minx[i]表示前1~i位置有多少个比x小的
maxx[i]表示1~i位置有多少个比x大的
然后我们枚举子串左右端点，枚举的过程中，判断该子串是否包含x并且他们的区间是否>x和<x的一样多，而判断某区间>x和<x是否一样多之间用
minx[j]-minx[i-1]==maxx[j]-maxx[i-1]即可
这个思路其实已经能干掉70%数据了，我在测试时只有最后两组数据没干掉，相对于蓝桥杯，能想到这个思路，估计已经能干掉大部分人了（QAQ），其实重点就是前缀和的处理（很巧妙，少了一层循环）
*/
#include<iostream>
using namespace std;
const int N=1e5+5;
int a[N],ans,minx[N],maxx[N];
int main()
{
	int n,x,t;
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]==x)t=i;
	}
	for(int i=1;i<=n;i++)//预处理过程基本上就是核心了
	{
		if(a[i]<a[t])minx[i]++;
		else if(a[i]>a[t])maxx[i]++;
	
		minx[i]+=minx[i-1];
		maxx[i]+=maxx[i-1];

	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		if(i<=t&&j>=t&&(minx[j]-minx[i-1])==(maxx[j]-maxx[i-1]))
		{
			ans++;
			//printf("%d %d\n",i,j);
		}
	}
//	for(int i=1;i<=n;i++)
//	printf("%d %d\n",minx[i],maxx[i]);
	printf("%d\n",ans);
	return 0;
}
```

#### 进阶2:

蓝桥杯省赛  K倍区间[传送门](http://oj.hzjingma.com/p/7165?view=classic)

> 思路：同样也是前缀和思路预处理，找出关系即可

#### 进阶3

```c++
[[CQOI2009]中位数图]https://ac.nowcoder.com/acm/problem/19913
这道题跟完美子串是一模一样的问题，只不过换了一种说法。
思路：可以拿上述完美子串的思路3可以直接ac本题，接下来我们对上述思路3进行优化
    /*
    1：对于中位数，我们肯定知道对于一个序列（排好序后），以中位数x为分界线，左边比x小的数和右边比x大的数个数相同，直接的想法就是暴力枚举每一种可能的区间，判断b是否在区间以及是否满足排好序后(暴力的话大可不必排序这个区间，只需枚举区间中比b大的个数和比b小的个数即可)小的和大的一样多，这种方法时间复杂度O（n^3）
    2:我们再此方法上对O（n^3）进行优化，我们是不是可以对这个排列预处理，也就是求前缀和，对于minx[i]表示前i个数中比b小的个数，maxx[i]表示前i个数中比b大的个数，那么我们只用两层循环就可以了O（n^2）。
    思路3：也就是最优解，对于某个区间{L,R}
    中位数b：左边---L小：表示在b左边比b小的个数
    			--L大：表示在b左边比b大的个数
    中文书b：右边---R小：表示在b右边比b小的个数
    			--R大：表示在b右边比b大的个数
    上述条件满足：L小+R小=L大+R大，变换一下：L小-L大=R大-R小=j			只要存在L小-L大=R大-R小	就说明这段区间{L，R}满足条件，
    接下来我们枚举从b开始到n的区间，求前缀和，maxx[i]和minx[i],并且统计cnt[maxx[i]-minx[i]=j]++，也就是这个j的数量，这里用map统计即可（因为考虑到可能存在负值情况，或者在统计值j的时候+n防止越界），上述过程就是在从b右边开始统计j的数量，那么我们是不是再从b左边开始求minx[i]-maxx[i]=j的值（注意这里和变换那里条件要一样），统计这个j值的数量是不是就是对答案的贡献，当然在枚举做区间时，要记得res=cnt[0],这种情况要先被加进去（因为=0的情况已经符合条件了，不懂得模拟一下即可）。最后输出res即可
    思路4：对思路3的优化，我们直接让这个区间中比b大的=1，比b小的=-1，那么直接用sum对右区间求前缀和，同时统计值的数量（这里看到其他的题解都是在统计的前把cnt[N]=1,然后又在统计过程中把cnt[0]贡献到答案中，而我是从b的位置开始统计相当于cnt[N]=1,然后统计完值，将res+=cnt[N]了，根据个人喜好把，理解即可），然后对左区间进行求后缀和，同时把贡献答案 */
    
```

```c++
//思路4的代码
#include<iostream>
using namespace std;
const int N=1e5+5;
int a[N],cnt[N>>1];//N>>1防止N过于大造成段错误（因为自己发生数组越界了QAQ）
int main()
{
    int n,b,pos;
    cin>>n>>b;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]>b)a[i]=1;
        else if(a[i]<b)a[i]=-1;
        else if(a[i]==b)a[i]=0,pos=i;
    }
    int sum=0,add=;
    for(int i=pos;i<=n;i++)
    {
        sum+=a[i];
        cnt[sum+n]++;
    }
    int res=0;
    res=cnt[n],sum=0;
    for(int i=pos-1;i>=1;i--)
    {
        sum+=a[i];
        res+=cnt[n-sum];
    }
    cout<<res<<endl;
    return 0;
}

```

## 差分

### 一维差分

> 差分可以在O(n)的时间内修改后进行O(1)查询
>
> 原数组：a[1],a[2]....a[n]
>
> 查分数组：b[1]=a[1],b[2]=a[2]-a[1],b[i]=a[i]-a[i-1]
>
> 给[l,r]区间加x，则对b[l]+=x,b[r+1]-=x
>
> 为什么？因为到了l这个点，就开始加x，而到了r+1，事实上从r+1以及以后都不需要加x，那么我们-x就相当于去掉了前边区间加的x（因为最后要还原成原数组，用到了前缀和）

```c++
void insert(int l.int r,int x)
{
    a[l]+=x;
    a[r+1]-=x;
}
int main()
{
	int l,r,x;
	cin>>n>>q;
	for(int i=1;i<=n;i++)//对这个数组中n个元素预处理
	{
		cin>>x;
		insert(i,i,x);//修改区间的值,也就是对l-r这个区间增加x
		//cin>>a[i];
	}
	while(q--)//进行q次询问
	{
		cin>>l>>r>>x;//每次修改区间值
		insert(l,r,x);
	}
	for(int i=1;i<=n;i++)//最后求一下前缀和即是原数组在某区间修改q此后的值
	a[i]=a[i]+a[i-1];
	for(int i=1;i<=n;i++)//输出修改后的值
	printf("%d ",a[i]);
	return 0;
 }
```

#### 例题

```c++
[裸题](http://oj.hzjingma.com/p/40?view=classic)
[进阶问题5998 - 专用牛棚](http://oj.hzjingma.com/p/5998?view=classic)                 
//这个是差分应用多次修改，求修改后最大值                
 [7897愤怒的FlappyBird 20'](http://oj.hzjingma.com/p/7897?view=classic) //这道题相比上一道，感觉这道题更难，目的就是将问题转换成差分思想，单次更新+1，最后求单次更新最小值以及最小值出现的次数
 //这两道进阶题更能体现差分的具体应用
[校门外的树](https://ac.nowcoder.com/acm/problem/16649)
//这道题，差分模板，但是当l数据范围在0~1e9时，我们就需要离散化了，可以试试离散化做做（虽然不用离散化，直接差分模板或者暴力都能AC，但还是要学下离散化做法，逃~）
```

#### 对例题补充

```c++
/*
5998 - 专用牛棚,这道题是差分的应用，不像裸的差分问题，直接一眼就能看出来是差分问题，这道题首先题意搞明白，有n头奶牛，产奶时间段在l到r，并且这个时间段奶牛不能被其他奶牛看见（言外之意就是给这个奶牛一个牛棚，而其他奶牛就不能进这个牛棚了），那么我们可以在每个奶牛他自己的时间段给他增加1个牛棚（也就是在区间l-r，进行+1操作，这里就是给他增加一个牛棚保证他在这个时间段可以产奶）最后我们通过差分操作在O（n）内就算出了区间操作，那么我们要的就是在某个时间点（注意这个是时间点）最大数（也就是进行区间修改后这个时间点的牛棚数最大，最大数满足我们在任意时间点都可以奶牛产奶而不被其他奶牛看见）
*/
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e6+5;
 int a[N];
void insert(int l,int r)
{
	a[l]+=1;
	a[r+1]-=1;
}
int main()
{
	int n,l,r;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>l>>r;//对区间+1
		insert(l,r);
	}
	int res=0;
	for(int i=1;i<=1e6;i++)//这个时间点最大在1e6
	{
		a[i]+=a[i-1];
		res=max(res,a[i]);
	}
	cout<<res<<endl;
	return 0;
 } 
/*
7897愤怒的FlappyBird 
第一种思路就是枚举每一种高度，找出该高度下撞坏柱子数，并且判断是否是最小柱子数，以及飞行高度的数量，时间复杂度O（n*h）,只能通过30%数据
*/
#include<iostream>
#include<cstdio> 
using namespace std;
const int N=1e6;
int a[N];
int main()
{
	int n,h,mincnt,flycnt;
	scanf("%d%d",&n,&h); 
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	mincnt=n;
	for(int i=1;i<=h;i++)//枚举每一种高度
	{
		int cnt=0;
		for(int j=1;j<=n;j++)//统计每种高度撞坏柱子数
		{
			if(j%2==1)
			{
				if(a[j]>=i)cnt++;
			}
			else
			{
				if(h-a[j]+1<=i)cnt++;
			}
		}
		if(cnt<mincnt)//是否是最小柱子数量
		{
			mincnt=cnt;
			flycnt=0;
		}
		if(cnt==mincnt)flycnt++;
		//printf("%d ",cnt);
	}
	printf("%d %d\n",mincnt,flycnt);
	return 0;
 } 
/*
7897愤怒的FlappyBird 
第二种思路就是枚举每个柱子的位置，奇数位置柱子在1~h'（h'为该柱子的高度）都会被撞坏，偶数位置柱子在区间(h-h'+1~h)都会被撞坏。所以每次让这个区间+1，最后统计在每个高度的最小值，也就是会撞坏的柱子数量，顺便在统计一下有多少个这样的高度即可
*/
#include<iostream>
#include<cstdio> 
using namespace std;
const int N=1e6;
int f[N],sum[N];
int main()
{
	int n,h,mincnt,flycnt,x;
	scanf("%d%d",&n,&h); 
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(i&1)
		{
			f[1]+=1;
			f[x+1]-=1;
		}
		else
		{
			f[h-x+1]+=1;
			f[h+1]-=1;
		}
	}
	for(int i=1;i<=h;i++)
	sum[i]=sum[i-1]+f[i];
	mincnt=n,flycnt=0;
	for(int i=1;i<=h;i++)
	{
		if(sum[i]<mincnt)
		{
			mincnt=sum[i];
			flycnt=0;
		}
		if(mincnt==sum[i])
		flycnt++;
	}
	printf("%d %d\n",mincnt,flycnt);
	return 0;
 } 
```



## 贪心：

> 贪心是一种思想，每次都是在寻找最优解。经典例题：过桥问题

```c+
/*思路：
n=1:a[0]
n=2:a[1]
n=3:a[0]+a[1]+a[2]
n>3:两种策略
假设由AB...YZ(n个人)
策略一：AZ,A,AY,A(此时剩下AB和....n-4个人)a[n-1]+2*a[0]+a[n-2]
策略二：AB,A,YZ,B(此时剩下AB和....n-4个人)2*a[1]+a[0]+a[n-1]
解释：策略一是让最快的带着最慢的走，最快的回来再继续带着次慢的走
	 策略二是先让最快的前两个过去，再让最快的回来，最慢的两个过去，再让次慢的回来
注意：以上模拟的是在n个人中让最慢的两个过桥，你会发现模拟一遍最快的两个都回到了原地，这是因为他们最快的两个任务就是把后n-2个人都送到桥那边，直到剩下不超过4个人的时候他们的任务就完成了，3个人以下只有一种策略是最优解，而n>3时有两种策略，我们比较两种策略的最优解也就是用时最小的（你想在每次送走2个之后我们都选择用时最短的是不是整体用时最短？你品，你细品！！！）
核心代码：
*/
for(int i=0;i<n;i++)
cin>>a[i];
while(n>=4)
{
	if(a[n-1]+2*a[0]+a[n-2]>=2*a[1]+a[0]+a[n-1])//选择最短时间的策略
	ans+=2*a[1]+a[0]+a[n-1];
	else
	ans+=a[n-1]+2*a[0]+a[n-2];
	n-=2;//循环把接下来最慢的两个送到桥那边
}
if(n==3)ans+=a[0]+a[1]+a[2];//三个人先让a[0]带着a[2]过去，a[0]回来，在带着a[1]过去
if(n==2)ans+=a[1];//两个人直接过去选择的是最慢的作为时间
if(n==1)ans+=a[0];//一个人直接过去
//over

```





## 二分

第一种：找第一个=mid的下标，也就是二分找下界

[学习资源](https://www.bilibili.com/video/BV1Ng4y1q7E3?from=search&seid=12973200640727135192)

```c++
int l=0,r=n-1;//找x，x可能有多个，例如x=2 [1，1,2,2,3]
while(l<r)
{
    int mid=l+(r-l)/2;
    if(a[mid]>=x)r=mid;
    else l=mid+1;
}
return l;
```

第二种：二分找上界

```c++
#include<bits/stdc++.h>
using namespace std;
unordered_map<int,int>mp; 
int main()
{
	int a[]={1,1,2,2,3};
	int l=0,r=4,x=2;
	while(l<r)
	{
		int mid=l+(r-l)/2;
		if(a[mid]<=x)l=mid+1;
		else r=mid;
	} 
	cout<<l<<"\n";
    return 0;
}
```

### 二分总结

```c++
/*
当区间在 [l,mid-1]--[mid,r]时，mid=l+(r-l+1)/2
目的就是保证不出现死循环，例如 l=2,r=3，如果是mid=l+(r-l)/2
那么第一次 mid=2 满足条件 l=mid 那么就会一直陷入死循环
*/
while(l<r)
{
    int mid=l+(r-l+1)/2;
    if(check(mid))l=mid;
    else r=mid-1;
}
cout<<l<<"\n";
```

### 二分答案

```c++
while(l<=r){
    int mid=(l+r)>>1;
    if(check(mid)){
        ans=mid;l=mid+1;
    }else r=mid-1;
}
```



### 二分小数

当存在精度时。

```c++
while(r-l>=1e-5){
    double mid=(l+r)/2;
    if(check(mid))l=mid;
    else r=mid;
}
printf("%.2lf\n",l);
```

案例：[今日头条笔试题](https://www.acwing.com/problem/content/682/)

### 求一个数的3次方根



基本不等式：
$$
\frac{a_{1}+a_{2}+a_{3}+...+a_{n}}{n}\geq\sqrt[n]{a_{1}\times a_{2}\times a_{3}\times ...\times a_{n}}
$$


```c++
int n;
cin>>n;
printf("%.3lf\n",pow(n,1.0/3))
    //利用这种方法n不能是负数....
 /*
 所以可以拓展到求k次方根，自己比赛时候傻了吧唧用二分写了
 题意：给你abc的乘积，求a+b+c最小和
 思路：基本不等式：上边--所以答案3*n（1/3）
   */
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e5+5;
typedef long long ll;
int main()
{
//	ios::sync_with_stdio(false);
    int n;
	cin>>n;
	double l=0,r=1e9;
	while(r-l>=1e-5)
	{
		double mid=(l+r)/2;
		if(mid*mid*mid>=n)r=mid;
		else l=mid;
	} 
	 printf("%.3lf\n",l*3);
	return 0;
 } 
```

## 高精

### 高精加

#### 高精加之结构体

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct BigNum{
	int num[105],len;
}A,B,C;//利用结构体存储数字和长度
char str[105];
void add(BigNum &x,BigNum &y,BigNum &z)
{
	int jw=0;//进位
	z.len=max(x.len,y.len);
	for(int i=0;i<=z.len;i++)//=z.len是因为最后有可能有进位的情况（把进位1也放进去） 
	{
		z.num[i]+=x.num[i]+y.num[i]+jw;
		jw=z.num[i]/10;
		z.num[i]%=10;
	}
	//cout<<z.len<<endl;
	if(z.num[z.len]) 
	z.len++;
	//cout<<z.len<<endl;
	
}
void print(BigNum &C){
	for(int i=C.len-1;i>=0;i--)
	cout<<C.num[i];
}
int main()
{
    // 读取并倒序存储大整数A 
	cin>>str;
	int len=strlen(str);
	A.len=len;
	for(int i=0;i<len;i++)//倒叙存储避免进位问题
	A.num[len-i-1]=str[i]-'0';
	// 读取并倒序存储大整数B
	cin>>str;
	B.len=len=strlen(str);
	for(int i=0;i<len;i++)
	B.num[len-i-1]=str[i]-'0';
	add(A,B,C);//计算结果
	print(C);//输出
	return 0;
}
```

对于add函数也可这样处理

```c++
void add(BigNum &x, BigNum &y, BigNum &z) {  
	z.len = max(x.len, y.len); // 结果最小长度为两者长度最大值 
	for(int i = 0; i < z.len; i++) z.num[i] = x.num[i] + y.num[i]; // 不进位加法得到初步结果 
	for(int i = 0; i < z.len; i++) 
		if(z.num[i] > 9) { // 进行逐位进位 
			z.num[i + 1] += 1;
			z.num[i] -= 10;
		}
	if(z.num[z.len]) ++z.len; // 判断最高位是否有进位 
}
```

#### 高精加之字符串string

```c++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>//用高了reverse字符串反转
using namespace std;
string add(string &a,string &b)//&可以避免重复复制字符串
{
	string c;//结果
	int t=0;//每次按位计算，包括了进位
	for(int i=a.size()-1,j=b.size()-1;i>=0||j>=0||t>0;i--,j--)//t>0是因为最后一次可能有进位出现而i,j已经<0
	{
		if(i>=0)t+=a[i]-'0';
		if(j>=0)t+=b[j]-'0';
		c+=t%10+'0';
		t/=10;
	}
	reverse(c.begin(),c.end());
	return c;
	//cout<<c<<endl;
}
int main()
{
	string a,b;
	cin>>a>>b;
	cout<<add(a,b)<<endl;
	return 0;
}
```

#### 高精加之vector

```c++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;
vector<int> add(vector<int>&A,vector<int>&B)
{
	if(A.size()<B.size())return add(B,A);
	vector<int>C;
	int t=0;
	for(int i=0;i<A.size();i++)
	{
		if(i<B.size())t+=B[i];
		t+=A[i];
		C.push_back(t%10);
		t/=10;
	}
	if(t)C.push_back(t);
	return C;
}
int main()
{
	string a,b;
	vector<int>A,B,C;
	cin>>a>>b;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
	C=add(A,B);
	for(int i=C.size()-1;i>=0;i--)
	cout<<C[i];
	cout<<endl;
	return 0;
}
```

#### yxc大佬高精加模板

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### 例题

##### 数楼梯

**题目描述**

 楼梯有N阶，上楼可以一步上一阶，也可以一步上二阶。

 编一个程序，计算共有多少种不同的走法。

 N<=5000

**输入格式**

 一个数字，楼梯数。

**输出格式**

 走的方式几种。

**输入样例**

```
4
```

**输出样例**

```
5
```

**思路：**n的范围有点大，采用高精处理

```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
int n,len=1,f[5003][5003];//f[k][i]--第k阶台阶所对应的走法数 
void hp(int k)//高精度加法，k来存阶数 
{    
    int i;
    for(i=1;i<=len;i++)
     f[k][i]=f[k-1][i]+f[k-2][i];//套用公式 
    for(i=1;i<=len;i++)             //进位 
     if(f[k][i]>=10)
     {
         f[k][i+1]+=f[k][i]/10;
         f[k][i]=f[k][i]%10;
         if(f[k][len+1])len++;
    }
}
int main()
{
    int i;
    scanf("%d",&n);
    f[1][1]=1; f[2][1]=2;         //初始化 
    for(i=3;i<=n;i++)              //从3开始避免越界 
     hp(i);                         
    for(i=len;i>=1;i--)             //逆序输出 
     printf("%d",f[n][i]);
    return 0;
}
```

### 高精减

> 通过字符串读取之后反向存入vector，判断A和B的关系A>B,计算sub(A,B)
>
> 否则计算sub(B,A)并且输出“-”。

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
bool cmp(vector<int> &A,vector<int> &B)
{
	//判断A>B则ans>=0否则ans<0 
	if(A.size()!=B.size())return A.size()>B.size();//判断A是否大于B
	for(int i=A.size()-1;i>=0;i--)//从高位开始判断 
	if(A[i]!=B[i])return A[i]>B[i]; 
	return true;//说明ans=0 
}
vector<int> sub(vector<int> &A,vector<int> &B)
{
	vector<int>C;
	for(int i=0,t=0;i<A.size();i++)
	{
		t+=A[i];
		if(i<B.size())t-=B[i];
		C.push_back((t+10)%10);
		if(t<0)t=-1;
		else t=0;
	}
	while(C.size()>1&&C.back()==0)C.pop_back();//消除高位的0，因为高位可能是两个相等的数相减所以会有0的情况
	return C;
}
int main()
{
	string a,b;
	cin>>a>>b;
	vector<int>A,B,C;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
	if(cmp(A,B))
	{
		C=sub(A,B);
		for(int i=C.size()-1;i>=0;i--)
		printf("%d",C[i]);
	}else
	{
		printf("-");
		C=sub(B,A);
		for(int i=C.size()-1;i>=0;i--)
		printf("%d",C[i]);		
	}
	printf("\n");
	return 0;
}
```



### 高精乘

> 1、模拟乘法规则，从A的个位到高位与B相乘，乘得的结果放入t中，则此位的数为t % 10.把t / 10剩余给下一个高位
>
> 2、若遍历完整个A，t > 0,则表示还有剩余的数，则需要将剩余的数继续补到下一个高位

#### 高精乘低精度

```c++
//C = A * b, A >= 0, b >= 0
#include<iostream>
#include<vector>
#include<string>
#include<cstdio>
using namespace std;
vector<int> mul(vector<int> &A,int b)
{
	vector<int>C;
	for(int i=0,t=0;i<A.size()||t;i++)
	{
		if(i<A.size())t+=A[i]*b;
		C.push_back(t%10);
		t/=10;
	}
	while(C.size()>1&&C.back()==0)C.pop_back();//作用是消除大数*0的情况 例如123*0 ，如果不消除高位0，则会有3个0，但结果应该是有1个0
	return C;
}
int main()
{
	string a;
	int b;
	cin>>a>>b;
	vector<int>A,C;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	C=mul(A,b);
	for(int i=C.size()-1;i>=0;i--)
	printf("%d",C[i]);
	printf("\n");
	return 0;
}
```

#### 高精乘高精

```c++
    2 1 0 //在num[]中下标
---------
    1 2 3 //a.num[]
*     3 2 //b.num[]
---------
    2 4 6 
+ 3 6 9
---------
  3 9 3 6 //ans.num[]
```

易发现：

- 乘法竖式中，`a.num[i]`和`b.num[j]`相乘的结果，放在了`ans.num[i+j]`的位置。
- `a,b`都为正整数时，长度为`a.len`和`b.len`的数字相乘得到`ans`，则a.len+b.len-1<=ans.len<=a.len+b.len

模拟上例竖式运算过程：

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
vector<int> mul(vector<int> &A,vector<int> &B)
{
	vector<int>C(A.size()+B.size());// 最大长度 
	for(int i=0;i<A.size();i++)//模拟乘法竖式 
	{
		for(int j=0;j<B.size();j++)
		{
			C[i+j]+=A[i]*B[j];
		}
	}
	for(int i=0,t=0;i<C.size();i++)// 进位处理 
	{
		t+=C[i];
		if(i>=C.size())C.push_back(t%10);
		else C[i]=t%10;
		t/=10;
	}
	while(C.size()>1&&C.back()==0)C.pop_back();
	return C;
}
int main()
{
	string a,b;
	cin>>a>>b;
	vector<int>A,B,C;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
	C=mul(A,B);
	for(int i=C.size()-1;i>=0;i--)
	cout<<C[i];
	cout<<endl; 
	return 0;
 } 
/*
进位处理也可以这样写
	for(int i=0;i<C.size();i++)
	{
	    C[i+1]+=C[i]/10;
	    C[i]%=10;
	}
*/
```

### 高精除低精

```c++
#include<iostream>
#include<vector>
#include<string>
#include<cstdio>
#include<algorithm>
using namespace std;
vector<int> div(vector<int> &A,int b,int &r)
{
	vector<int>C;
	r=0;
	for(int i=A.size()-1;i>=0;i--)//从高位开始处理 
	{
		r=r*10+A[i];
		C.push_back(r/b);
		r%=b;
	}
	reverse(C.begin(),C.end());
	while(C.size()>1&&C.back()==0)C.pop_back();//除去0
	return C;
}
int main()
{
	string a;
	int b,r;
	cin>>a>>b;
	vector<int>A,C;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	C=div(A,b,r);
	for(int i=C.size()-1;i>=0;i--)
	printf("%d",C[i]);
	printf("\n");
	printf("%d\n",r);
	return 0;
}
```

# 基本数据结构

## 字符串

### BF算法：

```c++
int BF(char s[],char t[],int pos)
{
    int i=0,j=0;
    int lens=strlen(s),lent=strlen(t);
    while(i<lens&&j<lent)
    {
        if(s[i]==t[j])//匹配成功
        {
            ++i;++j;
        }
        else//匹配不成功
        {
            i=i-j+1;//i重新匹配
            j=0;
        }
    }
    if(j==lent)return i-j;//返回匹配成功时第一个字符的下标
    else return -1;//没有与s串匹配成功
}
```



```c++
int BF(char s[],char t[],int pos)
{
    int i=0,j=0,res=0,lens=strlen(s),lent=strlen(t);
	while(i<lens)
    {
        while(i<strlen(s)&&t<strlen(t))
        {
            if(s[i]==t[j])
            {
                ++i;++j;
            }
            else
            {
                i=i-j+1;
                j=0;
            }
        }
        if(j==lent)res++;//求能够匹配多少个子串
        if(i==lens)return res;
        else
        {
            i=i+j-1;
            j=0;
        }
    }
}
```

**思路：**都从下标0开始匹配，当出现匹配不成功时，t串从0开始，s串从i-j+1开始继续。

### kmp算法：

先解释字符串的前后缀

给定串：ABCABA

前缀：A,AB,ABC,ABCA,ABCAB,ABCABA  真前缀：A,AB,ABC,ABCA,ABCAB

后缀：A,BA,ABA,CABA,BCABA,ABCABA 真后缀：A,BA,ABA,CABA,BCABA

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int maxn=1e6+5;
char s[maxn],t[maxn];
int nextp[maxn],lens,lent;
void get_next()//获取next数组
{
	int i=0,j=-1;
	nextp[0]=-1;
	while(i<lent)
	{
		if(j==-1||t[i]==t[j])
		nextp[++i]=++j;
		else
		j=nextp[j];//失配
	}
}
void KMP()
{
	int i=0,j=0,res;//从0位开始匹配res(子串在主串中有多少个可匹配的子串)
	while(i<lens)
	{
		if(j==-1||s[i]==t[j])
		{
			++i;++j;
		}
		else
		j=nextp[j];
		if(j==lent)//匹配成功
		{
			res++;
            j=nextp[j];
		}
	}
    return res;
}
int main()
{
	cin>>s>>t;
	lens=strlen(s);
	lent=strlen(t);
	get_next();
	cout<<KMP()<<endl;
	return 0;
 } 
```

### next数组的含义

next[i]=k表示从0~i-1位置子串的前缀和后缀相同的最大长度为k,并且k代表着与当前,后缀最大匹配的前缀位置。

| 下标   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| :----- | ---- | :--- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 字符串 | a    | a    | b    | a    | a    | b    | a    | a    | b    | a    | a    | b    |      |
| next[] | -1   | 0    | 1    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |

next[12]=9，9所在的下标前缀= aabaabaab  与后缀aabaabaab是最大匹配

即next[i]=k，表示前i个的的最大公共前后缀匹配长度为k

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
string str;
int nextp[100005];
void get_next()//获取next数组
{
	int i=0,j=-1;
	nextp[0]=-1;
	while(i<str.size())
	{
		if(j==-1||str[i]==str[j])
		nextp[++i]=++j;
		else
		j=nextp[j];//失配
	}
}
int main()
{
	cin>>str;
	get_next();
	for(int i=0;i<=str.size();i++)
        cout<<nextp[i]<<" ";
	return 0;
} 
```



### 最长公共字符串后缀

> 理解前缀和后缀的概念，"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合

```c++
/*
求a，b的公共字符串后缀=str，然后再求str和c的公共字符串，以此类推
其实就是模拟题
*/
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
const int N=2e2+5;
string f(string a,string b)//求a，b字符串的公共字符串后缀
{
	string ans="";
	for(int i=a.length()-1,j=b.length()-1;i>=0&&j>=0;i--,j--)
	{
		if(a[i]==b[j])
		ans+=a[i];
	}
	return ans;
}
int main()
{
	int n;
	string a,b,s[N],str;
	while(cin>>n&&n)
	{
		for(int i=0;i<n;i++)
		cin>>s[i];
		str=f(s[0],s[1]);
		reverse(str.begin(),str.end());//求的str是后缀的公共字符串如果继续，需要反转以下才能继续
		for(int i=2;i<n;i++)
		{
			str=f(str,s[i]);
			reverse(str.begin(),str.end());//记得反转，在algorithm下
		}
		cout<<str<<endl;
	}
	return 0;
 } 
//[传送门](https://www.acwing.com/problem/content/781/)
```

字符串最大跨距

> 题意：给定S和S1，S2，其中S1在S的左边并且是他的子串，S2在S右边是他的子串，且S1右边界小于S2的右边界，求他们之间的最大距离，其中会有重复的子串

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
	string str,S1,S2;
	char c;
	int i=0;
	while(cin>>c)//输入格式
	{
		if(c!=',')
		{
			if(i==0)str+=c;
			else if(i==1)S1+=c;
			else if(i==2)S2+=c;
			
		}else i++;		
	}
	int s1,s2;
	s1=str.find(S1);
	s2=str.rfind(S2);
	if(s1!=-1&&s2!=-1&&s1+S1.size()-1<s2)
	cout<<s2-s1-S1.size();
	else cout<<"-1";
	cout<<endl;
	//cout<<s1<<" "<<s2<<endl;
	
	return 0;
}
//[传送门](https://www.acwing.com/problem/content/780/)
//回车 加ctrl+z查看结果
```

### 字符串的子序列和子串的区别

```c++
子串必须是连续的，而子序列可以是不连续的
    构造题：https://ac.nowcoder.com/acm/contest/6037/C
```

## 单调队列

### 滑动窗口

> 固定一个大小为k的窗口，每次滑动后求出窗口的最大值和最小值（单调队列）

```c++
#include<iostream>
#include<deque>
#include<cstdio>
using namespace std;
deque<int>q1,q2;
const int N=1e6+5;
int n,k,a[N];
void maxx()//窗口最大值同下
{
	for(int i=0;i<n;i++)
	{
		while(!q1.empty()&&a[i]>a[q1.back()])
		q1.pop_back();
		if(!q1.empty()&&q1.front()<i-k+1)
		q1.pop_front();
		q1.push_back(i); 
		if(i>=k-1)cout<<a[q1.front()]<<" ";
	}
	cout<<endl;
}
void minx()
{
	for(int i=0;i<n;i++)
	{
		while(!q2.empty()&&a[i]<a[q2.back()])//首先队列不空，其次当要插入元素小于窗口内元素，窗口内元素就要pop出去
		q2.pop_back();
		if(!q2.empty()&&q2.front()<i-k+1)//当最左端不在窗口内移除
		q2.pop_front();
		q2.push_back(i); //这里进入的是元素的下标
		if(i>=k-1)cout<<a[q2.front()]<<" ";//当达到窗口开始出去元素
	}
	cout<<endl;
}
int main()
{
	cin>>n>>k;
	for(int i=0;i<n;i++)//n个数，窗口大小为k
	scanf("%d",&a[i]);
	minx();//窗口求最小值
	maxx();//窗口最大值
	return 0;
 }
//时间复杂度O(n)
//模板题：http://oj.hzjingma.com/p/27?view=classic
```

### 滑动窗口进阶

> 最大子序和问题：输入一个长度为n的整数序列，从中找出一段长度不超过M的连续子序列，使得整个序列的和最大。

> 问题分析：如果这个题目没有长度不超过m这个条件限制，就是一道动态规划入门题。（最大子段和）暴力枚举所有满足长度的子串，利用前缀和求其子串的和，时间复杂度O(nm)枚举两个端点会超时，那么我们就只枚举其右端点，快速的找左端点。枚举右端点j,在[j-m+1,j]中找一个左端点i,使得以j结尾的[i,j]区间连续子序和最大。
>
> →[i,j]区间子序和为sum[j]-sum[i-1]
>
> →sum[j]已经固定了，所以等价于找一个最小的sum[i-1].
>
> 这便是单调队列的经典应用了，题库**P0027滑动窗口**，

```c++
//这道题的细节很多，比如为什么要维护窗口m+1大小？为什么不需要if(i>=m)这个条件？其实就是从模板那里变形，掌握这道题更能能够理解单调队列的精髓吧
#include<iostream>
#include<deque>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=3e5+5;
int a[N],n,m,sum[N],res;
deque<int>q;
void maxx()
{
	for(int i=1;i<=n;i++)
	{
		while(!q.empty()&&sum[i]<sum[q.back()])
		q.pop_back();
		if(!q.empty()&&q.front()<i-m)//这里应该维护的是m+1大小的窗口 
		q.pop_front();
		q.push_back(i);
		//if(i>=m)//其实这里不需要的因为我们求的是任意的sum[j]-sum[i-1] 
		//cout<<sum[i]-sum[]
		res=max(res,sum[i]-sum[q.front()]);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
		sum[i+1]=sum[i]+a[i];
	}
	res=a[0];//我们要找的是最大子序和，由于可能有负数最大和所以答案直接在元素内产生不会影响答案
	maxx();
	cout<<res<<endl;
	return 0;
}
//if(i>=m)//其实这里不需要的因为我们求的是任意的sum[j]-sum[i-1] 
//这个数据被卡，原因是：n=m=16222 我们直接求出来的是 sum[n]-min(sum[i),
//所以会错，因为我们的sum[j]任意 
```

## 单调栈

> 裸题：对于i这个位置求右边第一个比他大的数字的下标

```c++
#include<iostream>
#include<stack>
#include<cstdio>
using namespace std;
const int N=3e6+5;
int a[N],res[N];
stack<int>s;
void f(int n)
{
	for(int i=1;i<=n;i++)
	{
		while(s.size()&&a[i]>a[s.top()])
		{
			res[s.top()]=i;
			s.pop();
		}
		s.push(i);
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	f(n);
	for(int i=1;i<=n;i++)
	printf("%d ",res[i]);
	return 0;
}
//洛谷要开启O（2）才能ac，或者用数组模拟栈应该会过 
//或者acwing600仰视奶牛（裸题）
```

## 搜索

### dfs

> 一条路走到黑，走到头倒回去

#### 全排列

暴力循环

```c++
//n的全排列需要n层循环
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
	int n;
	cin>>n; 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(j!=i)
			for(int k=1;k<=n;k++)
			{
				if(k!=j&&k!=i)
				printf("%d%d%d\n",i,j,k);
			}
		}
	}
	return 0;
 } 
```

#### 搜索

```c++
# include<iostream>
# include<string.h>
using namespace std;
bool visit[100]={0};
int a[100];
void dfs(int cur,int n)
{
	int i;
	if(cur==n)
	{
		for(i=0;i<n;i++)
		{
			cout<<a[i];
		}
		cout<<endl;
	}
	else
	{
		for(i=1;i<=n;i++)
		{
			if(!visit[i])
			{
				a[cur]=i;
				visit[i]=true;
				dfs(cur+1,n);
				visit[i]=false;
			}
		}
	}
}
int main()
{
	int n; 
	while(cin>>n&&n)
	{
		memset(a,0,sizeof(a));
		dfs(0,n);
	}
	return 0;
}
/*
	例题：
	寒假作业：http://oj.hzjingma.com/p/7005?view=classic
	思路：需要剪枝
*/
```

#### 子集生成

##### 二进制法

```c++
//紫书190
int a[35];//集合中的元素
void f(int n,int s)
{
    for(int j=0;j<n;j++)
        if(s&(1<<j))//s就是二进制的状态，而1<<j利用了非0即为真
            printf("%d ",a[j]);
}
int main()
{
    for(int i=0;i<1<<n;i++)//总共有2^n个子集
    {
        f(n,i);//将i变成二进制，而二进制的状态1就是选0就是不选
    }
    return 0;
}
/*
直接可以写成两个循环
*/
for(int i=0;i<1<<n;i++)
{
    for(int j=0;j<n;j++)
        if(i&(1<<j))
            cout<<a[j]<<" ";//每个内层循环是为了输出每个子集
    cout<<endl;
}
/*
1<<j解释：对于每个i都是一种子集（变成二进制），而我们在内层循环里要做的其实就是把这个二进制表示的01把其中的1所对应状态给选出来，而1<<j&i就是判断二进制下的i每一位其中有1的选出来。
其实这里也可以直接把i的二进制通过>>移位的操作选出1，具体操作如下
*/
for(int i=0;i<1<<n;i++)
{
    int t=i;//因为t需要变化，所以用中间变量代替i
    for(int j=0;j<n;j++)
    {
        if(t&1)
            cout<<a[j]<<" ";//每个内层循环是为了输出每个子集
        t>>1;//每次移位都要找出其中的1
    }
    cout<<endl;
}
```

##### 位向量法

```c++
//其实就是用搜索的方法，选和不选的状态递归下去
#include<iostream>
using namespace std;
int a[3],b[3];
void dfs(int cur)
{
	if(cur==3)
	{
		for(int i=0;i<3;i++)
		if(b[i])cout<<a[i]<<" ";
		cout<<"\n";
		return ;
	}
	b[cur]=1;
	dfs(cur+1);
	b[cur]=0;
	dfs(cur+1);
}
int main()
{
	int n; 
	for(int i=0;i<3;i++)
	cin>>a[i];
	dfs(0); 
	return 0;
 } 
```

##### 位向量法拓展

```c++
/*
位向量法其实就是求子集生成，其实这是搜索的一种形式，通过选和不选两种状态我们可以解决很多其他问题，例如dp的背包问题
题意：有一个箱子容量V（0<=V<=20000），n个物品（0<n<=30），每个物品都有一个体积，求n个物品任取若干个装入箱内，使箱子的剩余空间最小。（也就是说把若干个物品放进箱子，尽量放满，不能溢出）--典型的背包问题
搜索思路：由于物品个数很小，考虑用搜索解决，因为是若干个物品，我们不知道物品个数，所以每个物品都有选和不选的状态。
链接：https://ac.nowcoder.com/acm/problem/16693
*/
#include<iostream>
#include<algorithm>
using namespace std;
int vis[35],res=0x3f3f3f3f,a[35];
void dfs(int cur,int v,int n,int sum)
{
	if(sum>v)return ;
	if(cur==n)
	{
		res=min(res,v-sum);
		return ;
	}
	vis[cur]=1;
	dfs(cur+1,v,n,sum+a[cur]);
	vis[cur]=0;
	dfs(cur+1,v,n,sum);
	
}
int main()
{
	int v,n;
	cin>>v>>n;
	for(int i=0;i<n;i++)
	cin>>a[i];
	dfs(0,v,n,0);
	cout<<res<<"\n";
	return 0;
} 
```



##### 例题

```c++
集合求和]：https://www.luogu.com.cn/problem/P2415
/*
#include<iostream>
#include<cstdio>
using namespace std;
const int N=35;
int main()
{
	int n=0,a[N],sum=0,x;
	while(scanf("%d",&x)!=EOF)
	a[n++]=x;
	for(int i=0;i<1<<n;i++)
	{
		int t=i;
		for(int j=0;j<n;j++)
		{
			if(t&1)
			sum+=a[j];
			t>>1;
		}
		
	}
	cout<<sum<<endl;
	return 0;
 } 
 //以上用二进制做的 60分，因为时间复杂度太大
*/
//其实这道题是结论题，对于求集合中所有子集之和，我们会发现集合中的每个元素在子集中出现的次数都是2^(n-1),所以res=sum*2^(n-1),sum是集合元素之和
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
int main()
    
{
	int n,x;
	ll sum=0;
	while(scanf("%d",&x)!=EOF)
	sum+=x,n++;
	cout<<ll(sum*pow(2,n-1))<<endl;
	return 0;
 } 
```



#### 八皇后问题

```c++
//以下是八皇后改（原题链接）：https://www.dotcpp.com/oj/problem2087.html
#include<iostream>
#include<algorithm>
using namespace std;
int vis[3][20],res,e[8][8],c[8],n=8;
void dfs(int cur)
{
	if(cur==n)
	{
		int sum=0;
		for(int i=0;i<n;i++)
		sum+=e[i][c[i]];
		res=max(res,sum);
	}
	for(int i=0;i<n;i++)
	{
		if(!vis[0][i]&&!vis[1][cur+i]&&!vis[2][cur-i+n])
		{
			c[cur]=i;
			vis[0][i]=vis[1][cur+i]=vis[2][cur-i+n]=1;
			dfs(cur+1);
			vis[0][i]=vis[1][cur+i]=vis[2][cur-i+n]=0;
		}
	}
}
int main()
{
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		cin>>e[i][j];
	}
	dfs(0);
	cout<<res<<endl;
	return 0;
}
```

#### 2n皇后问题

```c++
//原题链接：https://www.dotcpp.com/oj/problem1460.html
/*
	蓝桥杯的真题：n*n棋盘放n个黑皇后和n个白皇后，要求同n皇后问题，并且地图上1能放0不能放皇后
	思路：先放n个白皇后，并且给白皇后放过的地方做标记（防止后边放黑皇后放到白皇后的位置），然后放完，我们再放n个黑皇后，判断的时候记得白皇后放过的位置不能再放
	问题：由于放n皇后是一行一列，所以我们就枚举每一行，也就不会出现同行放2个皇后，所以不需要判断同行的条件，然后就是cur表示当前行i表示当前列，所以[cur][i]就表示某行某列，还有就是vis的判断条件要分开写，不能用一个来判断黑白皇后的条件，这里利用二维数组做判断条件，比较方便
*/
#include<iostream>
#include<algorithm>
using namespace std;
int vis_white[3][20],res,e[8][8],n;
int white_e[8][8];
int vis_black[3][20];
void dfs_black(int cur)
{
	if(cur==n)
	{
		res++;
		return ;
	}
	for(int i=0;i<n;i++)
	{
		if(!vis_black[0][i]&&!vis_black[1][cur+i]&&!vis_black[2][cur-i+n]&&e[cur][i]==1&&!white_e[cur][i])
		{
			vis_black[0][i]=vis_black[1][cur+i]=vis_black[2][cur-i+n]=1;
			dfs_black(cur+1);
			vis_black[0][i]=vis_black[1][cur+i]=vis_black[2][cur-i+n]=0;
		}
	}
}
void dfs(int cur)
{
	if(cur==n)
	{
		dfs_black(0);
	}
	for(int i=0;i<n;i++)
	{
		if(!vis_white[0][i]&&!vis_white[1][cur+i]&&!vis_white[2][cur-i+n]&&e[cur][i]==1)
		{
			//c[cur]=i;
			white_e[cur][i]=1;
			vis_white[0][i]=vis_white[1][cur+i]=vis_white[2][cur-i+n]=1;
			dfs(cur+1);
			//c[cur]=0;
			white_e[cur][i]=0;
			vis_white[0][i]=vis_white[1][cur+i]=vis_white[2][cur-i+n]=0;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		cin>>e[i][j];
	}
	dfs(0);
	cout<<res<<endl;
	return 0;
}
```



### bfs

```c++
//模板
#include<iostream>
#include<string>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e3+5;
string e[N];
int n,m,ex,ey,vis[N][N],dir[4][2]={0,1,1,0,0,-1,-1,0},res;
struct node{
	int x,y,step;
	node(int x,int y,int step):x(x),y(y),step(step){}
};
void bfs()
{
	queue<node>q;
	while(!q.empty())q.pop();
	q.push(node{0,0,0});
	vis[0][0]=1;
	while(!q.empty())
	{
		node h=q.front();
		if(h.x==ex&&h.y==ey)
		{
			res=h.step;
			return ;
		}
		q.pop();
		for(int i=0;i<4;i++)
		{
			int x=h.x+dir[i][0];
			int y=h.y+dir[i][1];
			if(x>=0&&x<n&&y>=0&&y<m&&e[x][y]!='*'&&!vis[x][y])
			{
					vis[x][y]=1;
					q.push(node{x,y,h.step+1});
			}
		}
	}
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>ex>>ey;//n行m列终点坐标
		ex-=1,ey-=1;
		for(int i=0;i<n;i++)
		cin>>e[i];
		bfs();
		cout<<res<<endl;
	}
	return 0;
}
```



```
//裸题
P1443马的遍历:https://www.luogu.com.cn/problem/P1443
//进阶（after与迷宫）
https://ac.nowcoder.com/acm/problem/14608
```

#### 三维bfs迷宫

```c++
//大致题意：从0,0,0开始走上下左右前后六个方向，走到n-1，n-1，n-1，其中.可以走，*不可以走，求最短距离
//原题：https://ac.nowcoder.com/acm/problem/201613
#include<iostream>
#include<queue>

using namespace std;
const int N=1e2+5;
int vis[N][N][N],n,res;
char e[N][N][N];
int dx[] = {0, 1, 0, -1 ,0 , 0}, dy[] = {1, 0, -1, 0, 0, 0}, dz[] = {0, 0, 0, 0, 1, -1};
struct node{
	int x,y,z,step;
};
bool judge(int x,int y,int z)
{
	if(x<0||x>=n||y<0||y>=n||z<0||z>=n)return false;
	return true;
}
void bfs()
{
	queue<node>q;
	while(!q.empty())q.pop();
	q.push(node{0,0,0});
	vis[0][0][0]=1;
	while(!q.empty())
	{
		node h=q.front();
		if(h.x==n-1&&h.y==n-1&&h.z==n-1)
		{
			res=h.step;
			return ;
		}
		q.pop();
		for(int i=0;i<6;i++)
		{
			int x=h.x+dx[i];
			int y=h.y+dy[i];
			int z=h.z+dz[i];
			if(judge(x,y,z)&&e[x][y][z]!='*'&&!vis[x][y][z])
			{
				vis[x][y][z]=1;
				q.push(node{x,y,z,h.step+1});
			}
		}
	
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	for(int k=0;k<n;k++)
	cin>>e[i][j][k];
	bfs();
	if(res)
	cout<<res+1;
	else cout<<"-1";
	cout<<"\n";
	
	return 0;
 } 
```



## 连通图

```c++
#include<iostream>
#include<string>
#include<vector> 
#include<algorithm>
#include<cstring>
using namespace std;
const int N=1e2+5;
string e[4];
int vis[4][N],m,cnt;
void dfs(int x,int y)
{
	if(x<0||x>=4||y<0||y>m)return ;
	if(vis[x][y]||e[x][y]!='*')return ;
	cnt++;//统计每个联通块中的数量
	vis[x][y]=1;
	for(int i=-1;i<=1;i++)
	for(int j=-1;j<=1;j++)
	dfs(x+i,y+j);
		
}
int main()
{
	vector<int>v1;
	cin>>m;
	for(int i=0;i<4;i++)
	cin>>e[i];
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<m;j++)
		if(e[i][j]=='*'&&!vis[i][j])
		{
			cnt=0;
			dfs(i,j);
			v1.push_back(cnt);
		}else vis[i][j]=1;
	}
	cout<<v1.size();//总共多少个联通块
	return 0;
 } 
```

```
进阶
模拟战役：https://ac.nowcoder.com/acm/problem/14698
```

## 求数的直径

```c++
/*两次dfs一次找到最远点，一次找到最大直径
*/
//#define fre yes
 
#include <cstdio>
#include <cstring>
 
const int N = 10005;
int head[N << 1], to[N << 1], ver[N << 1];
int d[N];
bool Vis[N];
 
int tot;
void addedge(int x, int y) {
    ver[tot] = y;
    to[tot] = head[x];
    head[x] = tot++;
}
 
void dfs(int u) {
    Vis[u] = true;
    for (int i = head[u]; ~i; i = to[i]) {
        int v = ver[i];
        if(!Vis[v]) {
            d[v] = d[u] + 1;
            dfs(v);
        }
    }
}
 
int diameter(int n) {
    int st = 1, mx = -1e9;
 
    dfs(st);
    for (int i = 1; i <= n; i++) {
        if(d[i] > mx) {
            mx = d[i];
            st = i;
        }
    }
 
    memset(d, 0, sizeof(d));
    memset(Vis, false, sizeof(Vis));
    dfs(st);
 
    mx = -1e9;
    for (int i = 1; i <= n; i++) {
        if(d[i] > mx) {
            mx = d[i];
        }
    } return mx;
}
 
int main() {
    memset(head, -1, sizeof(head));
    static int n;
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addedge(u, v);
        addedge(v, u);
    }
 
    printf("%d\n",diameter(n));
    return 0;
}
```



# 数学

## 算术基本定理

唯一分解定理一般指算术基本定理

任何一个大于1的[自然数](https://baike.baidu.com/item/自然数/385394) N,如果N不为**[质数](https://baike.baidu.com/item/质数/263515)**，那么N可以唯一分解成有限个质数的乘积。***N***=P1^a1P2^a2P3^a3......Pn^an，这里P1<P2<P3......<Pn均为[质数](https://baike.baidu.com/item/质数)，其中指数ai是正整数。这样的分解称为 ***N*** 的标准[分解式](https://baike.baidu.com/item/分解式/7490414)

用途：质因数求解最小公倍数或最大公因数

![](https://gitee.com/pingfan443/picture-img/raw/master/img/c/c1.png)

## 最小公倍数

公式法：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
typedef long long ll;
ll gcd(ll a,ll b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int a,b;
    cout<<a/gcd(a,b)*b;//先除后乘，避免溢出
	return 0;
 } 
```

质因数分解法：

这里用到了[唯一分解定律]([https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/10920095?fr=aladdin](https://baike.baidu.com/item/算术基本定理/10920095?fr=aladdin))当求n个数的最小公倍数，n<=1e6,a[i]<=1e5,答案对1e9+9取模，可以知道最多有1e6个数，最大是1e5，这个时候在用公式法，一定会错，因为最小公倍数在计算过程中有除法，取模后就不是正确答案了，这个时候转化为质因数分解，例如2,4,6,8分别为2,2^2,2*3,2^3,那么res=2^3 *3

思路：我们只需要保存每个数被分解后的质因子的最高次幂，需要注意下有的可能不会被分解完，例如21=3*7，最后x=7，需要特判。另外针对该题，可以知道最大为1e5，而我们的n最大是1e6,所以有很多重复的数，可以去重，不去重会超时

```c++
//例题（呼兰河传）：https://ac.nowcoder.com/acm/contest/6037/E
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+9,N=1e6+5;
typedef long long ll;
int vis[N],pri[N],vis2[N];
int cnt;
unordered_map<int,int>mm;
void prime()
{
	int len=sqrt(1e5);
    vis[0]=vis[1]=1;
    for(int i=2;i<=len;i++)
    {
        if(!vis[i])
        {
        	pri[++cnt]=i;
            for(int j=i*2;j<=len;j+=i)
                vis[j]=1;
        }
    }
}
ll qpow(ll a,ll b)
{
	ll res=1;
	while(b)
	{
		if(b&1)res=(res*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return res%mod;
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	prime();
	int n,x;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(!vis2[x])
		{
			vis2[x]=1;
			for(int j=1;j<=cnt&&x>=pri[j];j++)
			{
				int cur=0;
				if(x%pri[j]==0)
				{
					while(x%pri[j]==0)
					{
						cur++;
						x/=pri[j];
					}
				}
				mm[pri[j]]=max(mm[pri[j]],cur);
			}
			if(x>1)
			{
				mm[x]=max(1,mm[x]);
			}
		}else continue;
		
	}
	ll ans=1;
	for(auto x:mm)
	{
		ans=(ans*qpow(x.first,x.second))%mod;
	}
	cout<<ans<<"\n";
	return 0;
} 
//也可以尝试另外一道：Celestial Resort。https://ac.nowcoder.com/acm/contest/6241/C
```



## 素数筛法

### 埃氏筛

O(n*loglogn)

```c++
//埃氏筛(求n以内的素数)
void prime(int n)
{
    vis[0]=vis[1]=1;//1肯定不是素数
    for(int i=2;i<=n;i++)//从2开始到cnt枚举
    {
        if(!vis[i])
        {
            prime[cnt++]=i;//统计素数
            for(int j=i<<1;j<=n;j+=i)
                vis[j]=1;//素数的倍数一定是素数
        }
    }
}
```

### 线性筛

O(n)

```c++
void prime(int n)
{
    for(int i=2;i<n;i++){
        if(!vis[i])prime[cnt++]=i;
        for(int j=0;j<cnt&&i*prime[j]<n;j++){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
```

### 质因数分解

```c++
void divide(int x)
{
    //i<=x/i<==>i*i<=x
    for(int i=2;i<=x/i;i++){
        if(x%i==0){
            while(x%i==0)x/=i;
            cout<<i<<'\n';//输出质因子
        }
    }
    if(x>1)cout<<x<<'\n';
}
```



### 素因子

```c++
//给定一个数判断他是不是素数，并且给出他的素因子
//https://ac.nowcoder.com/acm/problem/14399
/*
由于数据范围很大（n<=1e9），采用试除法，我们只需要判断2~sqrt(n)，即可判断一个数是不是素数，然后在判断的过程中统计素因子（也就是所有的因子中是素数的）当n能够被i整除，说明一定不是素数，这个时候统计他的素因子，记得把所有n/i除尽，while(n%i==0)n/=i，当n==1说明统计完毕
*/
#include<iostream>
#include<cmath>
#include<vector>

using namespace std;

int main()
{
	int n,t;
	cin>>t;
	while(t--)
	{
		cin>>n;
		vector<int>res;
		int x=sqrt(n);
		bool flag=false;
		for(int i=2;i<=x;i++)
		{
			if(n%i==0)
			{
				flag=true;
				res.push_back(i);
				while(n%i==0)
				n/=i;
			}
			if(n==1)break;//不必在去统计
		}
		if(!flag)
		{
			cout<<"isprime"<<"\n"<<n<<"\n";
		}
		else
		{
			cout<<"noprime"<<"\n";
			for(int i=0;i<res.size()-1;i++)//输出因子
			cout<<res[i]<<" ";
			cout<<res.back();//避免最后末尾有空格
			if(n!=1)cout<<" "<<n;//还有素因子没被统计（例如21  7不会被统计，必须特判）
			cout<<"\n";
		}
	}
	return 0;
 } 
```

## 辗转相处算法

```c++
int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
```

总结：该算法是求最大公约数，当两个数的gcd=1，那么他们是互质的

相关例题：约分（一个分子分母都很大的数）

## 离散化

> 简单的来说就是，当数据范围太大，数组放不下（数组大概也就能放1e7）就需要用到离散化

### 例题

```c++
[校门外的树](https://ac.nowcoder.com/acm/problem/16649)
//这道题，差分模板，但是当l数据范围在0~1e9时，我们就需要离散化了，可以试试离散化做做（虽然不用离散化，直接差分模板或者暴力都能AC，但还是要学下离散化做法，逃~）
 /*
 离散化处理：对于m次操作，我们定义最多N=2*m个长度（可以类比成一个节点有两个子节点，左边2*i-1,右边2*i+1），结构体长度确定后，内部pos存储的是区间的位置，num存储区间端点的值，在处理输入时，就是总共m次操作，每次操作在2*i-1处保存左端点位置和他的值，右端点同样如此.然后在差分操作时，我们都是在左端点位置+1，右端点位置的下一位-1。这里需要排个序，按照位置的从小到大排序，枚举位置，当存在sum==1说明可能会是左端点（因为还有区间覆盖的情况）当sum==1&&a[i].num==1这个肯定是在左端点位置，我们只需统计答案即可，最后不要忘记最后一个位置与l之间还可能存在贡献答案的可能
 */
#include<iostream>
#include<algorithm>
using namespace std;
const int N=2e2+5;
struct node{
    int pos,num;
    bool operator < (const node&rhs)const{
        return pos<rhs.pos;
    }
}a[N];
int main()
{
    int l,m;
    cin>>l>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        a[2*i-1].pos=x;
        a[2*i-1].num=1;
        a[2*i].pos=y+1;
        a[2*i].num=-1;
    }
    sort(a+1,a+2*m+1);
    int sum=0,ans=0;
    for(int i=1;i<=2*m;i++)
    {
        sum+=a[i].num;
        if(sum==1&&a[i].num==1)//保证该位置在左端点
        {

            ans+=a[i].pos-a[i-1].pos;
        }
    }
    ans+=l-a[2*m].pos+1;
    cout<<ans<<endl;
    return 0;
}
       
```

## 卡特兰数（catlan）

[学习资源](https://www.bilibili.com/video/BV1nE411A7ST?from=search&seid=7259962434137301036)

递推公式1：f(n)=f(0)f(n-1)+f(1)f(n-2)+f(2)f(n-3)+......+f(n-1)f(0)

条件：(f(0)=1,f(1)=1,f(2)=2,f(3)=5)

```c++
#include<iostream>
#define ll long long 
using namespace std;
const int N=1e5+5;
int main()
{
	int n;
	cin>>n;
	ll a[20]={1};//a[0]=1
	for(int i=1;i<=n;i++)//递推求i
	{
		for(int j=0;j<i;j++)//对于每个i（i即为n）求公式
		a[i]+=a[j]*a[i-j-1];
	 } 
	 cout<<a[n]<<"\n";
	return 0;
 } 

```

组合公式：f(n)=C(2n,n)/(n+1)(n=0,1,2...)

```c++
#include<iostream>
using namespace std;
typedef long long ll;
ll f(int n, int m)
{
 	ll ans=1;
 	if(m<n-m)m=n-m;
 	for(int i=m+1;i<=n;i++)
 	ans*=i;
 	for(int i=1;i<=n-m;i++)
 	ans/=i;
 	return ans;
}
 int main()
 {
 	int n;
 	//用公式求解 C(2n,n)/(n+1)
 	//	cout<<f(2*n,n)/(n+1);
 	cin>>n;
 	ll ans=f(2*n,n)/(n+1);
 	cout<<ans<<endl;
 	return 0;
  } 
```



1. n个节点的二叉树有多少种画法？

简单画一下，可画出f(0)=1，f(1)=1,f(2)=2,f(3)=5,f(4)=14

f(5)=f(0)f(4)+f(1)f(3)+f(2)f(2)+f(3)f(1)+f(4)f(0)

那么f(n)=f(0)f(n-1)+f(1)f(n-2)+f(2)f(n-3)+......+f(n-1)f(0)

条件(f(0)=1,f(1)=1,f(2)=2,f(3)=5)

```c++
卡特兰数：
http://oj.hzjingma.com/contest/problem?id=140&pid=4&_pjax=%23p0
思路：首先就是8个节点的画法求 f(n),然后还需要知道的是编号不同位置也算做一种，所以res=f(n)7!
```



2. 括号匹配（n对括号多少种画法）

1 一堆括号 （） 1种

2 两队括号 （）（）	（（））	2两种

3 三队括号	()()(),((())),()(()),(())(),(()())	5种

f(n)=f(0)f(n-1)+f(1)f(n-2)+f(2)f(n-3)+......+f(n-1)f(0)	(f(0)=1,f(1)=1,f(2)=2,f(3)=5)

3. 买票问题

电影院售票5元，无零钱，并且没零钱不卖给你。一种是霍比特人（H）每个人手里5元，另一种是兽人（O）10元，所以必须先H买票，才能O买（因为O去了必须找钱）

```c++
问题（《编程之美》4.3买票找零）：2n个人排队买票，其中n个人持50元，n个人持100元。每张票50元，且一人只买一张票。初始时售票处没有零钱找零。请问这2n个人一共有多少种排队顺序，不至于使售票处找不开钱？
```



1对	HO

2对 HHOO	HOHO	

3对HOHOHO，HOHHOO，HHOOHO，HHOHOO，HHHOOO

f(3)=f(0)f(2)+f(1)f(1)+f(2)f(0)

f(n)=f(0)f(n-1)+f(1)f(n-2)+f(2)f(n-3)+......+f(n-1)f(0)	(f(0)=1,f(1)=1,f(2)=2,f(3)=5)

4. 分割三角形

f(n)=f(0)f(n-1)+f(1)f(n-2)+f(2)f(n-3)+......+f(n-1)f(0)	(f(0)=1,f(1)=1,f(2)=2,f(3)=5)

5. 栈

```
问题大意是用S表示入栈，X表示出栈，那么合法的序列有多少个(S的个数为n)
https://www.luogu.com.cn/problem/P1044
洛谷模板题
```

6. 2020-7-5蓝桥杯省赛第一场的E题矩阵

```c++
思路：先找规律
    2*1
    方案数 1
    2*2
    方案数 2
    2*3
    方案数 5
    满足卡特兰数
```

## 任意三角形面积

海伦公式：

已知三角形三边a,b,c，则

（[海伦公式](https://baike.baidu.com/item/海伦公式)）

![img](https://bkimg.cdn.bcebos.com/formula/8bc7bbda8115c4a084ababeaaa11ac0b.svg)

`S=sqrt[p(p-a)(p-b)(p-c)]`

```c++
例题：[蓝桥杯2018决赛]三角形面积
   http://oj.ecustacm.cn/problem.php?id=1386
```

## 约瑟夫环问题

> 给定n个人和k，n个人进行报数。当数到k这个人退出，继续从1开始数，问最后剩一个人的编号

1. 用队列模拟

```c++
#include<bits/stdc++.h> 

using namespace std;
const int N=1e5+5;
int main()
{
	int n,k;
	cin>>n>>k;
	queue<int>q,t;
	for(int i=1;i<=n;i++)q.push(i);
	int cnt=0,pos=0;
	while(q.size()>1){
		t=q;
		queue<int>t2;
		while(t.size()){
			int temp=t.front();
			t.pop();
			cnt++;
			if(cnt==k){
				cnt=0;
			}else{
				t2.push(temp);
			}
		}
		q=t2;
	}
	cout<<q.front()<<'\n';
	return 0;
}
```

2. 数学公式

```c++
/*
看不懂模拟一下即可
*/
#include<bits/stdc++.h> 
using namespace std;
const int N=1e5+5;
int main()
{
	int n,k;
	cin>>n>>k;
	int last=0;
	for(int i=2;i<=n;i++){
		last=(last+k)%i;
	}
	cout<<last+1<<'\n';
	return 0;
}
```



# RMQ问题

RMQ(Range Minimum/Maximum Query)区间最值

[敌兵布阵](http://acm.hdu.edu.cn/showproblem.php?pid=1166)

## 线段树

单点修改+区间查询

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int tree[N<<2],a[N];
void build(int p,int l,int r)
{
	if(l==r){
		tree[p]=a[l];return ;
	}
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	tree[p]=tree[p*2]+tree[p*2+1];	
}
void update(int p,int l,int r,int idx,int x)
{
	if(l==r){
		tree[p]+=x;
		a[idx]+=x;
		return ;
	}
	int mid=l+r>>1;
	if(idx<=mid)update(p*2,l,mid,idx,x);
	else update(p*2+1,mid+1,r,idx,x);
	tree[p]=tree[p*2]+tree[p*2+1];	
} 
int query(int p,int l,int r,int ql,int qr)
{
	int mid=l+r>>1;
	if(ql<=l&&r<=qr){
//		cout<<tree[p]<<'\n';
		return tree[p];
	}
	if(qr<=mid)return query(p*2,l,mid,ql,qr);
	if(ql>mid)return query(p*2+1,mid+1,r,ql,qr);
	return query(p*2,l,mid,ql,qr)+query(p*2+1,mid+1,r,ql,qr);
}
int main()
{
	int t,x,y,cnt=1;
	string s;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		build(1,1,n);
		cout<<"Case "<<cnt++<<":"<<'\n';
		while(1){
			cin>>s;
			if(s[0]=='E')break;
			cin>>x>>y;
			if(s[0]=='Q'){
				cout<<query(1,1,n,x,y)<<'\n';
			}else if(s[0]=='A'){
				update(1,1,n,x,y);
			}else if(s[0]=='S'){
				update(1,1,n,x,-y);
			}
		}
	}
  return 0;
}
/*

*/


```

### 区间查询+区间修改

学习：[传送门](https://blog.csdn.net/weixin_43914593/article/details/108221534)

模板题。！！！懒标记

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N=5e5+5;
inline ll ls(ll p){return p<<1;}
inline ll rs(ll p){return p<<1|1;}
ll tree[N<<2],x,tag[N<<2];
void push_up(ll p)
{
	tree[p]=tree[ls(p)]+tree[rs(p)];
}
void build(ll p,ll pl,ll pr)
{
	if(pl==pr){
		scanf("%lld",&x);tree[p]=x;
		return ;
	}
	ll mid=pl+pr>>1;
	build(ls(p),pl,mid);
	build(rs(p),mid+1,pr);
	push_up(p);
}
void addtag(ll p,ll pl,ll pr ,ll d)
{
	tag[p]+=d;
	tree[p]+=d*(pr-pl+1);
}
void push_down(ll p,ll pl,ll pr)
{
	if(tag[p]){
		ll mid=pl+pr>>1;
		addtag(ls(p),pl,mid,tag[p]);
		addtag(rs(p),mid+1,pr,tag[p]);
		tag[p]=0;
	}
}
void update(ll p,ll pl,ll pr,ll l,ll r,ll d)
{
	if(l<=pl&&pr<=r){
		addtag(p,pl,pr,d);
		return ;
	}
	push_down(p,pl,pr);
	ll mid=pl+pr>>1;
	if(l<=mid)update(ls(p),pl,mid,l,r,d);
	if(r>mid)update(rs(p),mid+1,pr,l,r,d);
	push_up(p);
}
ll query(ll p,ll pl,ll pr,ll l,ll r)
{
	if(l<=pl&&pr<=r)return tree[p];
	push_down(p,pl,pr);
	ll res=0;
	ll mid=pl+pr>>1;
	if(l<=mid)res+=query(ls(p),pl,mid,l,r);
	if(r>mid)res+=query(rs(p),mid+1,pr,l,r);
	return res;
}
int main()
{
	int n,m;
	ll op,lx,ly,d;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	while(m--){
		scanf("%lld",&op);
		if(op==1){
			scanf("%lld%lld%lld",&lx,&ly,&d);
			update(1,1,n,lx,ly,d);
		}else if(op==2){
			scanf("%lld%lld",&lx,&ly);
			printf("%lld\n",query(1,1,n,lx,ly));
		}
	}
  return 0;
}
```



## 树状数组

[动态求连续区间和](https://www.acwing.com/problem/content/1266/)

[罗勇军文章](https://blog.csdn.net/weixin_43914593/article/details/107842628)

单点修改+区间查询

```c++
#include<bits/stdc++.h>

using namespace std;
const int N=1e5+5;
int tree[N],n,m;
int lowbit(int x)
{
    return x&-x;
}
void update(int x,int d)
{
    while(x<=n){
        tree[x]+=d;
        x+=lowbit(x);
    }
}
int sum(int x)
{
    int ans=0;
    while(x>0){
        ans+=tree[x];
        x-=lowbit(x);
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        update(i,x);
    }
    for(int i=1;i<=m;i++){
        int k,a,b;
        cin>>k>>a>>b;
        if(k==0){
            cout<<sum(b)-sum(a-1)<<'\n';
        }else{
            update(a,b);
        }
    }
    return 0;
}
```



# LCA算法

## 介绍

LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。

## 朴素解法

**两种思路**：[传送门](https://www.bilibili.com/video/BV155411h7CG?p=1)

## 在线-倍增算法

模板题：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

具体思路：[模板题解](https://www.bilibili.com/video/BV155411h7CG?p=1)---[b站动画视频讲解](https://www.bilibili.com/video/BV1nE411L7rz?from=search&seid=14825796559052754297)

```c++
/*
dep[u]表示深度-即从根节点到u节点的深度
fa[u][i]表示u节点往上第2^i祖先
思路：对于 100% 的数据， 500000N≤500000，500000M≤500000。因为边数最5e5,所以f[u][i]其中i最大取到20就可以满足条件，因为2^20大约1e6符合题意。
1. 第一步就是算出来dep[u](dfs跑一遍树即可)
2.在第一步已经把f[u][0]算出来了，所以接下来就是预处理倍增
3.根据前两步来进行LCA(x,y)
	首先dep[x]让他最大，方便后边计算
	现在就是把让dep[x]和dep[y]相等
	for(int i=0;i<=20;i++){
		if((1<<i)&dx)
		x=f[x][i];
	}
	因为当前他们的深度已经相等，只需判断深度相同下，是否是同一个节点。
	是则找到了最近公共祖先，不是说明他门同深度，但不同节点。需要往上走。
	接下来就是找他门最近公共祖先的下边一个节点。
	最后返回f[x][0]即可
*/
#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>

using namespace std;
const int N=5e5+5;
vector<int>e[N];
int f[N][25],dep[N];

void dfs(int u,int fa)
{
	f[u][0]=fa;
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		dfs(v,u);
	}
}
int LCA(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	int dx=dep[x]-dep[y];
	for(int i=0;i<=20;i++){
		if((1<<i)&dx)
		x=f[x][i];
	}
	if(x==y)return x;
	
	for(int i=20;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
int main()
{
	int n,m,s,u,v;
	scanf("%d%d%d",&n,&m,&s);
	for(int i=0;i<n-1;i++){
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(s,s);
	//预处理倍增
	for(int i=1;i<=20;i++){
		for(u=1;u<=n;u++)
			f[u][i]=f[f[u][i-1]][i-1];
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		int lca=LCA(u,v);
		printf("%d\n",lca);
	} 
	return 0;
}
```

## 例题

[[蓝桥杯2018决赛]版本分支](http://oj.ecustacm.cn/problem.php?id=1400)

一般做法：不知道lca算法只能模拟。一直找父亲，出现父亲是u则找到，否则没有

```c++
#include<iostream>

using namespace std;
const int N=1e5+5;
int pre[N];
bool dfs(int u,int v){
	if(pre[v]==u)return true;
	else if(pre[v]==0)return false;
	else dfs(u,pre[v]);
}
int main()
{
	int n,q;
	cin>>n>>q;
	for(int i=0;i<n-1;i++){
		int u,v;
		cin>>u>>v;
		pre[v]=u;
	}
	for(int i=0;i<q;i++){
		int u,v;
		cin>>u>>v;
		if(u==v)cout<<"YES";
		else{
			int flag=dfs(u,v);
			if(flag)cout<<"YES";
			else cout<<"NO";
		}
		cout<<"\n";
	}
	return 0;
}
```

lca做法：其实就是求x和y的最近公共祖先。

# 快速幂

时间复杂度log2(n)

## 进制非递归计算快速幂

思路：我们把 b 写成二进制，例如 b=110(2)

 那 a^b = a^2 * a^4

我们可以从后往前遍历 b 的二进制的每一位，同时维护 a^2k, 假设 b 的该位二进制有 1, 就让答案乘上 a^2k

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll q_pow(ll a,ll b,ll p)
{
    ll res=1%p;
    while(b)
    {
        if(b&1)res=(res*a)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return res;
}
int main()
{
    ll a,b,p;
    cin>>a>>b>>p;
    cout<<q_pow(a,b,p)<<"\n";
    return 0;
}
//例如 a^10=a^(1010)2=a^(1*2^3+0*2^2+1*2^1+0*2^0)=a^(1*2^3+1*2^1)

```

## 例题

快速幂与高精的结合：[416.麦森数](https://www.acwing.com/problem/content/418/)

# 矩阵快速幂

[学习资源](https://www.bilibili.com/video/BV1z4411m7TF)

题意：给定一个矩阵，求矩阵的m次幂

```c++
/*
测试地址：https://vjudge.net/problem/51Nod-1113
 */   
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e2+5,mod=1e9+7;
typedef long long ll;
int n,m;
struct node{
	ll a[N][N];
}res,temp;//res存储结果
void init()//单位矩阵
{
	for(int i=1;i<=n;i++)
	res.a[i][i]=1;
}
node mul(node &a,node &b)
{
	node t;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			t.a[i][j]=0;//初始化0
			for(int k=1;k<=n;k++)
			t.a[i][j]=(t.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
		}
	}
	return t;//返回中间结果
}
void quick_pow()
{
	init();
	while(m)
	{
		if(m&1)res=mul(res,temp);
		temp=mul(temp,temp);
		m>>=1;
	}
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	cin>>temp.a[i][j];
	quick_pow();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		cout<<res.a[i][j]<<" ";
		cout<<"\n";
	}
	return 0;
 } 
```

## 用矩阵加速递推式

题意：给定斐波那契数列，在求前n项的平方和

范围：1~1e18

```c++
/*	
	斐波那契
	https://ac.nowcoder.com/acm/contest/7047/A
*/
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e2+5,mod=1e9+7;
typedef long long ll;
ll n;
struct node{
	ll a[3][3];
}res,temp;
void init()
{
	for(int i=1;i<=2;i++)
	res.a[i][i]=1;
	temp.a[1][1]=1;
	temp.a[1][2]=1;
	temp.a[2][1]=1;
	temp.a[2][2]=0;
}
node mul(node &a,node &b)
{
	node temp;
	for(int i=1;i<=2;i++)
	{
		for(int j=1;j<=2;j++)
		{
			temp.a[i][j]=0;
			for(int k=1;k<=2;k++)
			temp.a[i][j]=(temp.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
		}
	}
	return temp;
}
void quick_pow(ll m)
{
	init();
	while(m)
	{
		if(m&1)res=mul(res,temp);
		temp=mul(temp,temp);
		m>>=1;
	}
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin>>n;
	if(n==1)
	{
		cout<<1<<"\n";
		return 0;
	}
	quick_pow(n);
	cout<<(res.a[1][1]*res.a[1][2])%mod<<"\n";
	return 0;
 } 
```



# 龟速乘

同快速幂一样的原理。

a*b%p

b=10;b(2)=1010;

a^b=a*(2+10)

O(log2N)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long  ull;
ull q_cheng(ull a,ull b,ull p)
{
    ull res=0;
    while(b)
    {
        if(b&1)res=(res+a)%p;
        a=(a*2)%p;
        b>>=1;
    }
    return res;
}
int main()
{
    ull a,b,p;
    cin>>a>>b>>p;
    cout<<q_cheng(a,b,p)<<"\n";
    return 0;
}
```



# 乘法逆元

[学习资源](https://www.bilibili.com/video/BV12E411c7QH?from=search&seid=16872605961010793328)

(a+b)%p=(a%p+b%p)%p

(a-b)%p=(a%p-b%p)%p

(a*b)%p=(a%p *b%p)%p

(a/b)%p=(a%p/b%p)%p 错-不满足分配律

定义：若在mod p意义下，对于一个整数a，有a*x≡1(mod p),那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元

应用：求取(a/b)%p等同于a*(b的乘法逆元)%p

求解逆元：利用费马小定理(p为质数)

```c++
/*
求(a/b%p)=a*(b的乘法逆元)%p
即(a/b%p)=a*(q_pow(b,p-2))%p
例题-牛牛和牛可乐的赌约：https://ac.nowcoder.com/acm/contest/7412/A
*/
#include<cstdio>
#include<cstring>
using namespace std;
typedef long logn ll;
ll qpow(ll a,ll b,ll c)
{
	ll ans=1;
	while(b)
	{
		if(b&1)
		  ans=(ans*a)%c;
		a=(a*a)%c;
		b>>=1;
	}
	return ans;
}
int main()
{
	int a,b,p;
	scanf("%d%d%d",&a,&b,&p);
	b=qpow(b,p-2,p);
	printf("%d",((a%p)*(b%p))%p);
	return 0;
}
```



# dp

## 递推

```c++
P1002 过河卒：https://www.luogu.com.cn/problem/P1002
//该题搜索40分，dp可拿满分，dp需要注意的是预处理，第一行第一列当存在有马那么其后都应该置位0
```

## 最长不下降子序列

```c++
for(int i=0;i<n;i++)
{
    f[i]=1;
    for(int j=0;j<i;j++)
    {
        if(a[j]<=a[i])
            f[i]=max(f[i],f[j]+1);
    }
}
```

### 进阶

题目：Is Bigger Smarter?

地址：[传送门](https://vjudge.net/problem/UVA-10131)

中文翻译：

就是找一个序列，体重严格递增，iq严格递减。

思路：将体重递增排序，iq递减排序，那么问题就变成了求iq的递减序列

注意事项：判断方面需要

```c++
if(e[i].w>e[j].w&&e[i].iq<e[j].iq&&dp[j]+1>dp[i])
{
    dp[i]=dp[j]+1;
    path[i]=j;//标记序列 
}
```

- 体重是严格递增的，所以需特判下体重是否严格递增，后边的就是递减序列的条件了

- 路径同时需要保存下来，（递归输出）
- 当前i保存紧跟他后边的那个数j

统计答案：

```c++
if(ans<=dp[i])
{
	pos=i;
	ans=dp[i];
}
```

- 等号不能省，原因：前边可能有等长的序列，我们要的序列n尽可能大

输出答案：

- 递归输出，因为我们最后标记的是序列最后一个数，递归反着输出



## 最长公共子序列

[y总讲解](https://www.acwing.com/video/946/)

```c++
/*
最长公共子序列：
f[i][j]=   1. f[i][0]=0,f[0][j]=0
			2. f[i][j]=f[i-1][j-1]+1(s1[i]==s[j])
			3.f[i][j]=max(f[i-1][j],f[i][j-1]);
*/

#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
const int N=1e3+5;
int f[N][N];
int main()
{
	string s1,s2;
	while(cin>>s1&&cin>>s2)
	{
//		cin>>s1>>s2;
		int n,m;
		n=s1.size();
		m=s2.size();
		s1=' '+s1;
		s2=' '+s2;
		for(int i=1;i<=n;i++)f[i][0]=0;
		for(int i=1;i<=m;i++)f[0][i]=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(s1[i]==s2[j]){
					f[i][j]=f[i-1][j-1]+1;
				}else{
					f[i][j]=max(f[i-1][j],f[i][j-1]);
				}
			}
		}
		cout<<f[n][m]<<'\n';
	}
	return 0;
}
/*
GCTAT
CGATTA 
ABCFBC
ABFCAB
*/
```



## 最大序列和问题

题意：有正有负的一个序列，求最大的子序和（保证子串连续）

```c++
/*1:动态规划
设f[i]以i结尾的连续的最大子序和，则f[i]=(f[i-1]+a[i],a[i]),最后再求一下最大的f[i](for(int i=0;i<n;i++)res=max(res,f[i]))
2:贪心
我们发现当sum<=0这种情况，他一定不会在继续为后边的序列贡献答案，所以枚举该序列，for(int i=0;i<n;i++){if(sum<=0)sum=0;sum+=a[i];res=max(res,sum)}
*/
```

## 最大序列和二维进阶

题意：求最大子阵[传送门](http://oj.ecustacm.cn/problem.php?id=1451)现在是二维，所以我们降维来做，f[i] [j]表示j列前缀和。然后枚举左上角枚举左下角以及枚举右端点。然后就可以用dp或者贪心求一维。

```c++
#include<iostream>

using namespace std;
const int N=505;
int f[N][N];
int main()
{
    int n,m,res=0,x,res2;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
        {
            cin>>x;
            f[i][j]=f[i-1][j]+x;
        }
    }
    // cout<<f[3][3]<<'\n';
    int sum=0;
    res=0-0x3f3f3f3f;
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            sum=0;
            for(int k=1;k<=m;k++){
                int t=f[j][k]-f[i-1][k];
                sum+=t;
                res=max(res,sum);
                if(sum<=0)sum=0;
            }
        }
    }
   cout<<res<<'\n'; 
    return 0;
}
```





**了解**

```c++
//用分治法解决,将序列分成两部分：左边最大和,右边最大和,最大和包含左边和右边
#include<iostream>
#include<cstdio>
#include<algorithm> 
using namespace std;
const int N=1e7+5;
int a[N];
int f(int l,int r)
{
	if(l==r)return a[l];//结束条件 
	int m=l+r>>1;
	int ans=max(f(l,m),f(m+1,r));
	int ll=0,rr=0,tmp=0;
	for(int i=m;i>=1;i--)
	{
		tmp+=a[i];
		ll=max(ll,tmp);
	}
	tmp=0;
	for(int i=m+1;i<=r;i++)
	{
		tmp+=a[i];
		rr=max(rr,tmp);
	}
	ans=max(ans,ll+rr);
	return ans;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	printf("%d\n",f(1,n));
	return 0;
} 
//超时了 
```



## 扔鸡蛋问题

```c++
/*
	f[i][j]在i高度j个鸡蛋的情况下，最优策略下的最坏情况的扔鸡蛋次数
	1.j个鸡蛋在足够多的情况下可以不用全部用完
	2.状态转移：
		不用第j个鸡蛋，方案数为f[i][j-1]
		使用第j个鸡蛋，有1~i层情况可以扔，假设在第k层扔
			在第k层扔鸡蛋：
				碎了：f[k-1][j-1]
				没碎：f[i-k][j]
枚举扔的楼层k，在所有可行方案中选择最大值即为最坏情况，答案就是这些情况的最小值				
*/
#include<iostream>
#include<algorithm>
using namespace std;
const int N=105;
int f[105][15];
void init(int n,int m)
{
    for(int i=1;i<=n;i++)f[i][1]=i;
    for(int i=1;i<=m;i++)f[1][i]=1;
}
int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        init(n,m);
        for(int i=2;i<=n;i++)
        {
            for(int j=2;j<=m;j++)
            {
                f[i][j]=f[i][j-1];//第j个鸡蛋没用，是从f[i][j-1]转移过来的
                for(int k=1;k<=i;k++)
                f[i][j]=min(f[i][j],max(f[i-k][j],f[k-1][j-1])+1);
            }
        }
        cout<<f[n][m]<<"\n";        
    }

    return 0;
}
/*

*/
```



## 区间dp

### **区间dp板子**

```c++
f[i][j]--区间i~j的代价
/*
转移方程：f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum(i~j))
求min(f[i][j],---)是因为f[i][j]在k从l到r-1每次都会求出一个f[i][j],循环一遍就能找到最小的f[i][j]
	1.区间len为什么从2开始？因为len=1的时候f[l][r]=0
	2.为什么是L+len-1<=n?因为区间长度=R-L+1,还不懂画个图一目连然
	3.为什么f[l][r]=INF?因为一开始假设代价最大，那么就能求出来代价最小，最内层循环一次就能求出来f[l][r]的最小代价。
*/
for(int len=2;len<=n;len++)//枚举的区间长度
{
    for(int l=1;l+len-1<=n;l++)//枚举左区间
    {
        int r=l+len-1;
        f[l][r]=INF;//因为求最小代价，赋值无穷大
        for(int k=l;k<r;k++)//枚举L~R的中间K
            f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum[r]-sum[l-1]);
    }
}
```

### 求一个字符串中回文子串的个数

[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```c++
/*
f[i][j]--i~j区间是否是回文串
	len=1 f[l][r]=1
	len>=2 ：s[l]==s[r]
		len=2 f[l][r]=1
		len>2 f[l][r]=f[l+1][r-1]
*/
class Solution {
public:
    int f[1005][1005];
    int countSubstrings(string s) {
        int n=s.size(),res=0;;
        for(int len=1;len<=n;len++)
        {
            for(int l=0;l+len-1<n;l++)
            {
                int r=l+len-1;
                if(len==1){
                    f[l][r]=1;res++;
                }else{
                    if(s[l]!=s[r])f[l][r]=0;
                    else {
                        f[l][r]=len==2?1:f[l+1][r-1];
                        if(f[l][r])res++;
                    }
                }
            }
        }
        return res;
    }
};
```

### 最长回文子串长度

[最长回文子串长度](https://www.acwing.com/problem/content/1526/)

```c++
/*
	f[i][j]-i~j区间是否是回文子串
	问题就变成了 如果f[l][r]这个区间是回文子串
	那么答案就是res=max(res,r-l+1)
*/
#include<bits/stdc++.h>
using namespace std;
int f[1005][1005];
int main()
{
    string s;
    getline(cin,s);
    int n=s.size(),res=0;
    for(int len=1;len<=n;len++)
    {
        for(int l=0;l+len-1<n;l++)
        {
            int r=l+len-1;
            if(len==1)
            {
                f[l][r]=1;
                res=max(res,r-l+1);
            }
            else{
                if(s[l]==s[r])f[l][r]=len==2?1:f[l+1][r-1];
                if(f[l][r])res=max(res,r-l+1);
            }
        }
    }
    cout<<res<<"\n";
    // cout<<s<<"\n";
    return 0;
}
```

### 进阶区间dp

题意：

```c++
给定一个字符串 。 我们令一个字符串的权值为一个字符串的最长对称前后缀长度。 请求出  的所有子串的权值的总和。 例如，"abcxyzcba" 的最长对称前后缀的长度为 ，因为 “abc” 和 “cba” 对称。
字符串的长度为 ，。 字符串均由小写英文字符组成。
说明
样例中，单个字符的子串的权值为 ，它们的和为 。 另外的权值为： "bacb" -> 1 "bacbdab" -> 2 "bdab" -> 1 "acbda" -> 1 所以权值和为 。
示例
输入：
"bacbdab"
输出：
12
```

[原题链接](https://tianchi.aliyun.com/oj/14491652514320995/73733636160164531)

思路：区间dp就可做，f[i] [j]表示i~j区间的回文子串长度（此长度是指aba 该区间长度=2），然后板子套一下，每次res+=f[l] [r]，但是要求的是某个子串的最长对称前后缀长度，所以还要讨论该子串的奇偶性，因为aba 贡献的答案是3,而f[l] [r]=2，所以还要加上1，同理abba贡献的答案是4，f[f] [r]=2,还要加上2，所以必须讨论奇偶性。我就是因为没有讨论奇偶性，一直wa。。。

```c++
class Solution {
    typedef long long ll;
    ll f[3005][3005];
public:
    /**
     * @param s: a string.
     * @return: return the values of all the intervals.
     */
    long long suffixQuery(string &s) {
        // write your code here
        ll res=0;
	   int n=s.size();
	   memset(f,0,sizeof(f));
	   for(int len=1;len<=n;len++)
	   {
			for(int l=0;l+len-1<n;l++)
			{
				int r=l+len-1;
				if(len==1)
				{
					f[l][r]=1;
				}else{
					if(s[l]==s[r])
					f[l][r]=f[l+1][r-1]+1;
				}
				res+=f[l][r];
				if(len&1&&f[l][r]==len/2+1)
				res+=f[l][r]-1;
				else if(!(len%2)&&len/2==f[l][r]) res+=f[l][r];
			}	   	
	   } 
	   return res;
    }
};
```



石子合并：[学习资源](https://www.acwing.com/video/459/)

题意：给你N堆沙子，要求每次合并相邻的两堆，合并的代价是sum(l,r)求合并成一堆的最小代价。

```c++
#include<iostream>
#include<algorithm>
#define INF 0x3f3f3f3f
using namespace std;
const int N=310;
int a[N],f[N][N],sum[N];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
    for(int len=2;len<=n;len++)
    {
        for(int l=1;l+len-1<=n;l++)
        {
            int r=l+len-1;
            f[l][r]=INF;
            for(int k=l;k<r;k++)
            f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum[r]-sum[l-1]);
        }
    }
    cout<<f[1][n]<<"\n";
    return 0;
}
```

石子合并2：[传送门](https://ac.nowcoder.com/acm/problem/50493)

题意：还是n堆沙子合并，只不过现在多了一个环的问题，也就是首尾相连，要求合并n-1次使得合并总代价最大和最小，分别求出最大和最小。

思路：对于环问题，最直接的就是将原数组扩大一倍，然后维护枚举的区间长度保持在n就行，因为他要合并n-1次。

```c++
#include<iostream>
#define INF 0x3f3f3f3f

using namespace std;
const int N=310*2;
int a[N],f[N][N],f2[N][N],sum[N];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)a[i+n]=a[i];
    for(int i=1;i<=2*n;i++)sum[i]=sum[i-1]+a[i];
    for(int len=2;len<=n;len++)
    {
        for(int l=1;l+len-1<=2*n;l++)
        {
            int r=l+len-1;
            f[l][r]=INF;
            for(int k=l;k<r;k++)
            {
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum[r]-sum[l-1]);
                f2[l][r]=max(f2[l][r],f2[l][k]+f2[k+1][r]+sum[r]-sum[l-1]);
            }
        }
    }
    int minx=INF,maxx=0;
    for(int i=1;i+n-1<=2*n;i++)
    {
        minx=min(minx,f[i][i+n-1]);
        maxx=max(maxx,f2[i][i+n-1]);
    }
    cout<<minx<<"\n"<<maxx;
    return 0;
}
```

## 树形dp

经典题型：数的最大独立集

数的最大独立集：对于n各节点的无根树，选出尽量多的节点，使得任何两个节点均不相等（称为最大独立集）

```c++
/*
	没有上司的舞会:https://www.acwing.com/problem/content/287/
	思路：
	定义f[N][2]
	f[i][0]没有选i节点，f[i][1]选i节点
	则转移方程：
	1.不选第i个节点
	f[i][0]+=max(f[v1][0],f[v1][1])+max(f[v2][0],f[v2][1])+......+max(f[Vn][0],f[Vn][1]);
	2.选择第i个节点
	f[i][1]+=f[v1][0]+f[v2][0]+..f[Vn][0]
*/
#include<bits/stdc++.h>
#define pb push_back//vector,deque
using namespace std;
const int N=6e3+5;
int f[N][2],a[N],n;
vector<vector<int>>e;
typedef long long ll;
void dfs(int u,int fa)
{
	f[u][1]=a[u];
	for(auto &v:e[u])
	{
		if(v==fa)continue;
		dfs(v,u);
		f[u][0]+=max(f[v][0],f[v][1]);
		f[u][1]+=f[v][0];
	}
}
int main()
{
     cin>>n;
     e.resize(n+1);
     for(int i=1;i<=n;i++)cin>>a[i];
     for(int i=1;i<=n-1;i++)
     {
     	int u,v;
     	cin>>u>>v;
     	e[u].push_back(v);
     	e[v].push_back(u);
	 }
	 dfs(1,-1);
	 cout<<max(f[1][0],f[1][1])<<"\n";
	return 0;
 } 
```

### 求解树的直径

#### 方法1

**树形dp**

```c++
b站详解：
https://www.bilibili.com/video/BV1FE411L7Tw/?spm_id_from=333.788.recommend_more_video.4

例题：https://ac.nowcoder.com/acm/contest/8755/H
```

**方法2**

两次dfs



## 状压dp

题意：给定一张 nn 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1<<20,M=20;
int f[N][M],dist[M][M];
/*
	f[S][j]==>从起点0出发经过S中所有点，到达终点j时的最短路径
	1.第一层循环枚举集合的状态，总共有1<<n中状态
	2.第二层枚举终点j，而枚举终点只有0~n-1,同时判断终点是否在集合S中
	3.枚举k，k=>0~n-1，先把j从集合中去掉，然后判断k是否在集合中，存在集合中就存在状态转移： 
	f[S][j]=min(f[S][j],f[S-(1<<j)][k]+dist[k][j]);
*/
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    cin>>dist[i][j];
    memset(f,0x3f3f3f3f,sizeof(f));
    f[1][0]=0;
    for(int S=1;S<1<<n;S++)
    {
        for(int j=0;j<n;j++)
        if(S>>j&1)
        {
            for(int k=0;k<n;k++)
            {
                if((S-(1<<j))>>k&1)
                f[S][j]=min(f[S][j],f[S-(1<<j)][k]+dist[k][j]);
            }
        }
    }
    cout<<f[(1<<n)-1][n-1]<<'\n';
    return 0;
}
```



## 背包问题

[学习资源](https://www.bilibili.com/video/BV1n741157pW)

### 01背包

> n件物品v容量的背包，第i件物品体积vi，价值wi,求将那些物品放入背包，使物品总体积不超过背包容量，且价值最大

```c++
原题链接：https://www.acwing.com/problem/content/2/
n=4,v=5
v[i]	w[i]
 1   	2
 2 		4
 3		4
 4		5   
```

- [ ] - [ ] | 物品\体积 | 0    | 1    | 2    | 3    | 4    | 5    |
    | :-------: | ---- | ---- | ---- | ---- | ---- | ---- |
    |     0     | 0    | 0    | 0    | 0    | 0    | 0    |
    |     1     | 0    | 2    | 2    | 2    | 2    | 2    |
    |     2     | 0    | 2    | 4    | 6    | 6    | 6    |
    |     3     | 0    | 2    | 4    | 6    | 6    | 8    |
    |     4     | 0    | 2    | 4    | 6    | 6    | 8    |



```c++
/*
f[i][j]表示前i个物品容量不超过j时的最大价值
那么：对于第i件物品有两种选择
1:不选择第i件物品 f[i][j]=f[i-1][j]
2：选择第i件物品 f[i][j]=f[i-1][j-v[i]]+w[i]，这里选择第i件物品本身就是容量j就要减去v[i]（因为我们已经选择了它）
最后求的是f[n][m]
首先要做的初始化
1：对于f[0~n][0]=0，不管多少个物品，他的体积=0，那么价值始终是0
2：对于f[0][0~n]=0,不管体积多大，他始终是0个物品那么价值始终是0
*/
#include<iostream>
using namespace std;
const int maxn=1e3+5;
int f[maxn][maxn],n,m;//n个物品，m背包体积
int v[maxn],w[maxn];//v[i],w[i]第i个体积和价值
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>v[i]>>w[i];
	for(int i=1;i<=n;i++)//枚举n个物品
	{
		for(int j=1;j<=m;j++)//枚举体积
		{
			f[i][j]=f[i-1][j];
			if(j>=v[i])//这里是因为我们选择的第i件物品的体积必须<=j才能够选他
			f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
		}
	}
	cout<<f[n][m]<<endl;
    return 0;
}
/*
总结：我改了一下第二层循环，直接从j=v[i]开始，然后发现有的样例是错的，原因：没有注意到这个是二维，还需要转移f[i][j]=f[i-1][j]这个状态。所以修改j=v[i]开始是错的。而在一维上，就可以这样，因为这个状态已经被转移了。最近复习发现的坑QAQ
*/
/*
*这里定义的是f[i][j]前i个物品体积不超过j时的最大价值，那么初始化条件应该是
f[i~n][0]=0,f[0][j~v]=0;
在二维dp的基础上，我们可以降低到一维dp，可以看到我们枚举的是n个物品，然后枚举v的体积，我们第二层循环每层的答案只与上一层有关，那么我们可以把第一维去掉，这里需要从后往前枚举体积v因为我们对答案的更新状态有两种，一种是不选很显然f[i][j]=f[i-1][j],转换成f[j]=f[j],没毛病，那么当选了第i个物品，f[i][j]=f[i-1][j-v[i]]+w[i],可以知道我们想要的答案是在上一层靠左边的，所以如果第二层循环从小到大枚举体积，会破坏掉对之后答案的贡献，只能从后往前枚举f[j]=f[j-v[i]]+w[i]
*/
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e3+5;
int f[N],v[N],w[N],n,V;
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
    {
    	for(int j=V;j>=v[i];j--)
    	f[j]=max(f[j],f[j-v[i]]+w[i]);
	}
	cout<<f[V]<<"\n";
    return 0;
}
```

### 完全背包

题意：与01背包一样，只不过现在物品可以选任意个装进背包中

思路：[传送门](https://www.acwing.com/solution/content/5345/)



```c++
//二维
//第一种思路（超时方法）
/*
https://www.acwing.com/video/945/    
y总分析完全背包问题
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int f[N][N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=m;j++)
        {
            f[i][j]=f[i-1][j];
            for(int k=0;k*v[i]<=j;k++)
            f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
        }
    }
    cout<<f[n][m]<<"\n";
    return 0;
}
/*该算法最后一组数据超时，下面算法去掉了k，没超时
第二种思路：去掉了枚举k的循环。证明方法：
f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-kv]+kw);
f[i][j-v]=max(f[i-1][j-v],f[i-1][j-2v]+2w,....,f[i-1][j-kw]+kw);
因此：f[i][j]=max(f[i-1][j],f[i][j-v]);
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int f[N][N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=m;j++)
        {
            f[i][j]=f[i-1][j];
            if(v[i]<=j)
            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
        }
    }
    cout<<f[n][m]<<"\n";
    return 0;
}
//第三种思路：换成一维，想一下，在01背包中一维时，体积是从大到小枚举，就是因为只有一维数组，在二维的时候第i层j列状态是从i-1层j列的左边转移过来的，而变成一维情况下，第i层状态还是从i-1层转移过来，只不过现在没有i-1层了，第i层就是第i-1层，所以通过从大到小枚举，就不会影响状态。证明方法在二维已给出。
#include<iostream>
using namespace std;
const int N=1010;
int f[N],v[N],w[N],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=v[i];j<=m;j++)
        f[j]=max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
    return 0;
}
```



### 多重背包问题1

[题意]([https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=1mbaqvmWJVhsbkQ7v8GRB344CGDOMnvj0U2fBr3aPwNzQtywTqJ5kEisq2TtUneE&search_content=%E8%83%8C%E5%8C%85](https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=1mbaqvmWJVhsbkQ7v8GRB344CGDOMnvj0U2fBr3aPwNzQtywTqJ5kEisq2TtUneE&search_content=背包))

思路：只是多了每个物品有s[i]个的情况，多一个循环枚举即可

```c++
//一维
#include<iostream>
using namespace std;
const int N=1010;
int f[N],v[N],w[N],s[N],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i]>>s[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)
        for(int k=0;k<=s[i];k++)
        if(v[i]*k<=j)
        f[j]=max(f[j],f[j-k*v[i]]+k*w[i]);
    }
    cout<<f[m]<<endl;
    return 0;
}
```







### 多重背包二进制优化

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
struct good{
    int v,w;
};
vector<good>goods;
int f[N];
int main()
{
    int n,V;
    cin>>n>>V;
    for(int i=1;i<=n;i++){
        int v,w,s;
        cin>>v>>w>>s;
        for(int k=1;k<=s;k*=2){
            s-=k;
            goods.push_back({v*k,w*k});
        }
        if(s>0)goods.push_back({s*v,w*s});
    } 
    for(auto x:goods){
        for(int j=V;j>=x.v;j--)
        f[j]=max(f[j],f[j-x.v]+x.w);
    }
    cout<<f[V]<<'\n';
    return 0;
}
```



### 分组背包问题

[传送门](https://www.acwing.com/problem/content/9/)

```c++
/*
	对于每个组内
	f[j]=max(max(f[j],f[j-v[1]]+w[1]),max(f[j],f[j-v[2]]+w[2]),.....,max(f[j],f[j-v[s]]+w[s]))
	也就是说对于每组选择一个最优解，选择组内第一个或者第二个或者第s个即可
*/
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int f[N],v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int s;
        cin>>s;
        for(int j=1;j<=s;j++)cin>>v[j]>>w[j];
        for(int j=m;j>=0;j--)
            for(int k=1;k<=s;k++)
            if(j>=v[k])f[j]=max(f[j],f[j-v[k]]+w[k]);
    }
    cout<<f[m]<<'\n';
    return 0;
}
```

# 图论

## 无根树转有根数

> 紫书353详细讲到了，其实就是递归实现无根树到有根数的转换，pre[i]数组标记的是i的父亲，那么我们随便指定一个节点为根节点，并标记pre[i]=-1，说明它是根节点。其他递归实现。

> 题目：输入一个拥有N个结点的无根树的边，指点一个结点为根节点，把这棵树转化为一棵有根树，输出各个节点的父亲编号。n<=10^6。

```c++
#include<iostream>
#include<vector>
using namespace std;
const int maxn=1e6+5;
vector<int>e[maxn];
int n,root,pre[maxn];
void read_tree()//构造图
{
    int u,v;
    cin>>n;
    for(int i=0;i<n-1;i++)//n个节点有n-1条边
    {
        cin>>u>>v;//构造无向图
        e[u].push_back(v);
        e[v].push_back(u);
    }
}
void dfs(int u,int fa)//将无根树转换为有根数
{
    int d=e[u].size();//寻找以u出发的边的个数
    for(int i=0;i<d;i++)//枚举每条u出发边
    {
        int v=e[u][i];//u->v
        if(v!=fa)//这是因为当存在枚举u-v中的v是u的父亲时，要结束，否则会无限循环
            dfs(v,pre[v]=u);//递归v寻找v的儿子，同时标记v的父亲时u
    }
}
int main()
{
    read_tree();
    cin>>root;
    pre[root]=-1;
    dfs(root,-1);
    for(int i=0;i<n;i++)
        cout<<i<<"fa is"<<pre[i]<<endl;
    return 0;
}
```



## 最短路

### 学习

```c++
https://www.bilibili.com/video/BV1u7411p7V8?t=1538
```

邻接表的学习（链式前向星）：[传送门](https://www.bilibili.com/video/BV1mJ411S7BB?from=search&seid=15746586883310528811)

单源最短路=（Dijkstra（贪心）和Bellman-Ford）

多源最短路=Floyd（dp）

负环：

### Bellman-ford

#### 描述

在国内 OI 界，你可能听说过的“SPFA”，就是 Bellman-Ford 算法的一种实现。（优化）

Bellman - ford算法是求含负权图的单源最短路径的一种算法，效率较差O(n*m)，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成.

为什么是松弛n-1次?简单来说就是从源点到一个点的最短路最极限的一种情况的路径需要经过全部的点，也就是需要松弛v-1次，这样，我们执行v-1次就可以保证所有的点都松弛到最佳的情况，如果执行了v-1次后还能继续松弛，那就说明图中有负权环，无解.

https://www.bilibili.com/video/BV15E411v7bE

#### 算法

```c++
//初始化
memset(dist,0x3f,sizeof(dist));
dist[1]=0//起点到起点距离为0
```



```c++
//初始化dist[1]=0;其他inf
for(int i=1;i<=n-1;i++)
{
    int flag=false;//优化（当内层循环一次也没进行过松弛操作可退出）
    for(int j=0;j<m;j++)
        if(dis[e[j].v]>dis[e[j].u]+e[j].w)//松弛操作
        {
             dis[e[j].v]=dis[e[j].u]+e[j].w
                 falg=true;
        }
    if(!flag)break;
}
```

[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

```c++
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
ll maxn=2147483647;
struct node{
	int u,v,w;
}e[500105]; 
ll dist[10105];
int main()
{
	int n,m,s;
	cin>>n>>m>>s;
	fill(dist+1,dist+n+1,maxn);
	dist[s]=0;
	for(int i=0;i<m;i++){
		cin>>e[i].u>>e[i].v>>e[i].w;
	}
	for(int i=1;i<n;i++){
		bool flag=false;
		for(int j=0;j<m;j++)
		{
			if(dist[e[j].v]>dist[e[j].u]+e[j].w)
			{
				dist[e[j].v]=dist[e[j].u]+e[j].w;
				flag=true;
			}
		}
		if(!flag)break;
	}
	for(int i=1;i<=n;i++)
	cout<<dist[i]<<" ";
	return 0;
 } 
```



#### 判断图中有无负权环

```c++
 void Bellman_frod()
 {
     for(int i=1;i<n;i++)
     {
         int flag=false;//优化（当内层循环一次也没进行过松弛操作可退出）
         for(int j=0;j<m;j++)
             if(dis[e[j].v]>dis[e[j].u]+e[j].w)//松弛操作
             {
                 dis[e[j].v]=dis[e[j].u]+e[j].w
                     falg=true;
             }
         if(!flag)break;
     }
     //判断是否是负权环（原理：上边松弛操作后就不可能在松弛了，如果还能进行松弛操作就说明存在负权环）
     for(int i=0;i<m;i++)//m代表边的的数目
         if(dis[e[j].v]>dis[e[j].u]+e[j].w)
             return true;//存在负权环
    	 return false;
 }
//经典例题 洛谷：（P3385 【模板】负环）[传送们](https://www.luogu.com.cn/problem/P3385)
/*
//这道题最后一个数据卡了一下，原因是：最后1没有和其他节点相连
//解决办法：add修改一下（就是加法）
int addd(int a,int b)
{
	if(a==inf||b==inf)return inf;
	else
	return a+b;
}
//待解决：还没彻底明白
*/
```

[P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)



### spfa

#### 描述

单源最短路SPFA即 Shortest Path Faster Algorithm。

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。

SPFA是Bellman-ford的一种优化，用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。该算法期望复杂度是O(ke)，但是可以被特殊数据卡到O(nm)*O*(*n**m*),所以如果图中没有负权边时不建议使用该算法。

#### 算法

```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
int u,v,w,s,dist[n+1],vis[n+1];//s起点，dist[i]存储第i个顶点离起点s的最短距离，vis[i]判断顶点i是否在队列中
struct edge{
    int v,w,next;
}e[m+1];//存储每条边的信息
void add(int u,int v,int w)//链式前向星代替邻接表存图（相当于领接表）
{
    cnt++;//cnt统计边的个数
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}
queue<int>q;
void spfa()
{
    memset(dist,0x3f,sizeof(dist));
    dist[s]=0;
    q.push(s);
    vis[s]=1;//s已经进入队列
    int u,v;
    while(!q.empty())
    {
        u=q.front();
        vis[u]=0;//u已经出队列
        q.pop();
        for(int i=head[u];i;i=e[i].next)
        {
            v=e[i].v;
            if(dist[v]>dist[u]+e[i].w)//松弛操作
            {
                dist[v]=dist[u]+e[i].w;
                if(vis[v]==0)//没有进入队列并且进行了松弛操作加入队列
                {
                    q.push(v);
                    vis[v]=1;//进入队列
                }
            }
        }
    }
}
int main()
{
    cin>>n>>m>>s;//n个顶点，m条边，s起点
    for(int i=0;i<m;i++)
    {
        cin>>u>>v>>w;
        add(u,v,w);
    }
    spfa();
    for(int i=1;i<=n;i++)//输出起点到i点的最短距离
        cout<<dist[i]<<" ";
}
```



### Dijkstra

#### 描述

该算法本质上的思想是贪心,它只适用于不含负权边的图.我们把点分成两类,一类是已经确定最短路径的点,称为"白点",另一类是未确定最短路径的点,称为"蓝点"。我们将初始点的dis设为0，其他点的dis设为无穷大，不断取出蓝点中距离最小的点对其他蓝点进行更新，然后将其改成白点。该算法的正确性是基于当所有边长都是非负数的时候，全局最小值不可能再被其他节点更新了，我们不断用当前全局最小值进行松弛可以保证正确性。

**特性**：处理非负权图，贪心策略，解决单源最短路问题

#### 算法

##### 堆优化

> 邻接表+堆优化

```c++
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=2e5+5;
typedef long long ll;
int n,m,s,cnt,vis[maxn],head[maxn];
ll dis[maxn];
struct edge{
	int v,w,next;
}e[maxn];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
struct node{
	int u;
	ll dis;
	bool operator <(const node&b)const{
	return dis>b.dis;
	}
};
void dij()
{
	for(int i=1;i<=n;i++)dis[i]=(i==1?0:0x3f3f3f3f);
	priority_queue<node>p;
	p.push(node{s,0});
	while(!p.empty())
	{
		node t=p.top();
		p.pop();
		int u=t.u,d=t.dis;
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v,w=e[i].w;
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				p.push(node{v,dis[v]});
			}
		}
	}
}
int main()
{
	int u,v,w;
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);
	}
	dij();
	for(int i=1;i<=n;i++)
	printf("%lld ",dis[i]);
	printf("\n");
	return 0;
} 
```

##### 例题

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

##### 邻接矩阵

```c++
void init()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            e[i][j]=inf;//对矩阵初始化，inf表示不存在边（i,j）
}
void dij()
{
    memset(dis,inf,sizeof(dis));
    dis[1]=0;
    for(int i=1;i<=n;i++)
    {
        int maxx=inf,x=0;
        for(int i=1;i<=n;i++)//找出最小的距离
            if(!vis[i]&&dis[i]>m)maxx=dis[x=i];
        vis[x]=1;//代表x已在最短路集合中
        for(int y=1;y<=n;y++)
            if(dis[y]>dis[x]+e[x][y])
                dis[y]=dis[x]+e[x][y];
    }
}
```

##### 例题

[P1359 租用游艇](https://www.luogu.com.cn/problem/P1359)

```c++
#include<iostream>
#include<vector>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=2e2+5;
const int inf=0x3f3f3f3f;
int e[maxn][maxn],dis[maxn],n,vis[maxn];
void dij()
{
	memset(dis,inf,sizeof(dis));
	dis[1]=0;
	for(int i=1;i<=n;i++)
	{
		int mx=inf,x=0;
		for(int i=1;i<=n;i++)
		if(!vis[i]&&dis[i]<mx)mx=dis[x=i];
		vis[x]=1;
		for(int y=1;y<=n;y++)
		if(dis[y]>dis[x]+e[x][y])
		dis[y]=dis[x]+e[x][y];
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		e[i][j]=inf;
	}

	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		cin>>e[i][j];
	}
	dij();
	printf("%d\n",dis[n]);
	return 0;
}
```



### Floyd

#### 描述

Floyd是一种可以以n^3复杂度处理处图上任意点对最短距离的算法，它的实现原理也很直观，我们假设从i出发到j，只有两种情况，第一种是i,j间本来就有边，另一种是我们从i走到k，再从k走到j，Floyd就是枚举出所有的i,j,k，以三层循环不断更新所有点对的最短路

**特性**：解决多源最短路问题

#### 算法

```c++
for(int k=0;k<n;k++)//中转节点
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            e[i][j]=min(e[i][j],e[i][k]+e[k][j]);
```

## 次短路

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
typedef long long ll;
int n,m,cnt,vis[maxn],head[maxn];
int dis[maxn],dis2[maxn];
struct edge{
	int v,w,next;
}e[maxn];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
struct node{
	int u;
	int dis;
	bool operator <(const node&b)const{
	return dis>b.dis;
	}
};
void dij()
{
	for(int i=0;i<n;i++)
	{
		dis[i]=(i==0?0:0x3f3f3f3f);
		dis2[i]=0x3f3f3f3f;
	}
	priority_queue<node>p;
	p.push(node{0,0});
	while(!p.empty())
	{
		node t=p.top();
		p.pop();
		int u=t.u,d=t.dis;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v,d2=d+e[i].w;
			if(dis[v]>d2)//如果父亲结点过来的距离小于最短路
			{
				swap(dis[v],d2);//那么当前最短路变成次短路，更新最短路
				p.push(node{v,dis[v]});
			}
			if(dis2[v]>d2&&dis[v]<d2)//若当前距离不能更新最短路，但比当前次短路小；或者从父亲结点过来的次短路比当前次短路小
			{
				dis2[v]=d2;//更新次短路
				p.push(node{v,dis2[v]});
			}
		}
	}
}
int main()
{
	int u,v,w;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	dij();
	cout<<dis2[n-1]<<"\n";
	return 0;
} 
```



## 并查集

### 初始化

```c++
for(int i=1;i<=n;i++)//n：n个节点
    pre[i]=i;
```

### 查询

```c++
int find(int x)
{
    if(x==pre[x])return x;
    else
        return pre[x]=find(pre[x]);//(含状态压缩)
}
```

### 合并

```c++
void merge(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    if(fx!=fy)pre[fx]=fy;
}
```

### 带权并查集

[传送门](https://blog.csdn.net/weixin_43914593/article/details/104108049)

```c++
int find(int x)
{
	if(x!=pre[x]){
		int f=pre[x];
		pre[x]=find(pre[x]);
		sum[x]+=sum[f];//更新节点x到父亲的距离
	} 
	return pre[x];
} 
void merge(int x,int y,int w)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy){
        pre[fx]=fy;
        sum[fx]=w+sum[y]-sum[x];
    }
}
/*
详解：
https://blog.csdn.net/yjr3426619/article/details/82315133
*/
```

### 并查集判断图是否存在环

并查集可以处理一个图内是否存在环，比如给定一张图，可以判断在该图是否有环存在。**思路**：n个顶点m条边，每次把边合并，当存在边的两个顶点都已经在一个集合中的时候，说明一定有环。

```c++
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e5+5;
typedef long long ll;
int pre[10],n,m;//n个顶点，m跳边 
vector<int>e[100];
int find(int x)
{
	return x==pre[x]?x:pre[x]=find(pre[x]);
} 
void init()
{
	for(int i=1;i<=n;i++)
	pre[i]=i;
}
bool merge(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	if(fx!=fy){
		pre[fx]=fy;
		return true;
	}
	else return false;
}
int main()
{
	cin>>n>>m;
	bool flag=true;
	init();
	for(int i=0;i<m;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
		if(!merge(u,v)){
			flag=false;
		}
	}
	if(flag)
	cout<<"无环存在";
	else cout<<"有环存在";
	return 0;
 } 
 /*
6 5
1 2
2 3
2 4
3 5
4 6
无环存在 
6 6
1 2
2 3
2 4
3 5
4 6
3 6
 */
```

### 经典例题

模板题[传送门](https://www.luogu.com.cn/problem/P3367)

试题 历届试题 合根植物[传送门](http://lx.lanqiao.cn/problem.page?gpid=T458)

> 思路：n行m列的植物，初始化节点，将k行的两个植物进行合并，最后遍历一遍查询多少个集合即可

P1536 村村通 [传送门](https://www.luogu.com.cn/problem/P1536)

> 思路：简单的并查集即可做，先将道路联通的合并起来也就是合并成集合，最后查找有多少个集合，ans-1即可

### 并查集变种题

[第十一届蓝桥杯第十题网络分析](https://www.acwing.com/problem/content/2071/)

#### 带权并查集

牛客的[关押罪犯](https://ac.nowcoder.com/acm/problem/16591)，思路：[传送门](https://www.bilibili.com/video/BV1nz411b75c)

```c++
#include<bits/stdc++.h>
#define pb push_back//vector,deque
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e5+5;
typedef long long ll;
int pre[20005*2],n,m;//n个顶点，m跳边 
struct node{
	int u,v,w;
	bool operator<(const node&rhs)const{
		return w>rhs.w;
	}
}e[N];
int find(int x)
{
	return x==pre[x]?x:pre[x]=find(pre[x]);
} 
void init()
{
	for(int i=1;i<=n*2;i++)
	pre[i]=i;
}
void merge(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	if(fx!=fy){
		pre[fx]=fy;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d %d %d",&u,&v,&w);
		e[i]={u,v,w};
	}
	init();
	sort(e+1,e+m+1); 
//	cout<<e[1].w<<'\n';
	for(int i=1;i<=m;i++){
		if(find(e[i].u)==find(e[i].v)){
			cout<<e[i].w<<'\n';
			return 0;
		}else{
			merge(e[i].u,e[i].v+n);
			merge(e[i].u+n,e[i].v);
		}
	}
	cout<<0<<'\n';
	return 0;
 } 
```

hdu 3038

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn =200010;
int s[maxn];       //集合
int d[maxn];       //权值：记录当前结点到根结点的距离
int ans;

void init_set(){                  //初始化
   for(int i = 0; i <= maxn; i++)
   {   s[i] = i; d[i] = 0;  }
}
int find_set(int x){              //带权值的路径压缩
    if(x != s[x]) {
         int t = s[x];            //记录父结点
         s[x] = find_set(s[x]);   //路径压缩。递归最后返回的是根结点
         d[x] += d[t];            //权值更新为x到根节点的权值
     }
    return s[x];
}

void merge_set(int a, int b,int v){    //合并
    int roota = find_set(a), rootb = find_set(b);
    if(roota == rootb){
       if(d[a] - d[b] != v)
          ans++;
    }
    else{
       s[roota] = rootb;    //合并
       d[roota] = d[b]- d[a] + v;
    }
}

int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        init_set();
        ans = 0;
        while(m--){
            int a,b,v;
            scanf("%d%d%d",&a,&b,&v);
            a--;
            merge_set(a, b, v);
        }
        printf("%d\n",ans);
    }
    return 0;
}

```



## 拓扑排序

### 力扣思维题

给你一个有向无环图，n个节点0~n-1，然后m条边，u->v，让你找到最小的点集使得从这些点出发能够遍历所有的点。

**思路**：首先这个是无环图，其次只要是入度为0的点一定会在点集中，因为它入读为0，只能从该点出发才能完整遍历所有点。只有某一个点入度不为0，那么他一定可以通过入度为0的点到达。[原题传送门](https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/)

### 板子

[原题链接](http://oj.hzjingma.com/p/36?view=classic)

**思路**：1.寻找入度为0的节点，并且让他们入队。2.不断删除入度为0的节点所连接的边，具体操作就是`--indu[v]`然后判断该节点是否在删完构成了入度为0的节点。是就入队。3.不断重复上述操作。**总结**：拓扑排序同时也可以处理图中环的存在并且输出。（思路就是拓扑排序一遍，然后还存在indu[x]>0）的节点就是环中的节点。同时还可以利用拓扑排序验证该图是否存在环。具体详见板子注释。

> vector+结构体+队列（拓扑排序有向无环图）

```c++
const int maxn=1e5+5;
int topo[maxn];//存储结果
vector<int>e[maxn];
int indegree[maxn];//节点的入度数
//1表示存在拓扑序0表示有环
void input(int n,int m)
{
	int u,v;
	for(int i=0;i<m;i++)
	{
		cin>>u>>v;
		e[u].push_back(v);
		//e[v].push_back(u);//这里我构造了无向图，其实应该构造有向图的，之所以
		//构造无向图也能通过的原因是：无向图在遍历某节点的边时，会重新再把入度为0
		//的也判断一下，但是此时 indegree[i]已经=0再自减的话变成-1，还是不能选择，因此不会出错 
		indegree[v]++;
	}
}
bool topo_sort()
{
    int cnt=0;
    queue<int>q;
    for(int i=0;i<n;i++)
    {
        if(in_degree[i]==0)
            q.push(i);
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        topo[cnt++]=u;
        for(int i=0;i<G[u].size();i++)
        {
            int v=G[u][i].v;
            if(--in_degree[v]==0)
                q.push(v);
        }
    }
    return cnt==n;//判断有没有环的存在，返回1说明cnt确实和n相等，没有环的存在，否则有环
}
```

### 例题

#### 蓝桥杯决赛题，利用拓扑排序求图中的环

[原题链接](http://oj.ecustacm.cn/problem.php?id=1348)

```c++
题意：给定一个无向图，求无向图中的一个环。并且输出该环
    思路：首先明确的是拓扑排序解决的是有向图的排序。但是该题是个无向图，可以换个方式思考，根据案例，我们把将入度为1的入队，然后一样的套路写。判断的时候也是判断入度为1，入队列。
```



**思路**：首先明确的是拓扑排序解决的是有向图的排序。但是

[P1113 杂务](https://www.luogu.com.cn/problem/P1113)

```c++
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=1e4+5;
vector<int>ee[maxn];
int ru[maxn],mx[maxn],n,ti[maxn],ans;
void topo_sort()
{
	queue<int>p;//该队列维护的是入度为0的顶点 
	for(int i=1;i<=n;i++)//寻找入度为0的顶点 
	if(ru[i]==0)
	{
		p.push(i);//找到入度为0的顶点 
		mx[i]=ti[i];//存储该顶点完成工作所需的时间 
	}
	//mx[u]=ti[u];
	while(!p.empty())
	{
		int u=p.front();
		p.pop();
		for(int i=0;i<ee[u].size();i++)
		{
			int v=ee[u][i];
			if(--ru[v]==0)
			{
				p.push(v);
			}
			mx[v]=max(mx[v],mx[u]+ti[v]);
		}
	}
	for(int i=1;i<=n;i++)//循环每个任务是因为有可能在n个任务重有一个任务完成时间最长，但是他是独自的一个连通分量
	ans=max(mx[i],ans);
	
}
int main()
{
	int a,b,c;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b>>c;//a工作序号，b工作时间，c表示以a为终点的顶点 
		ti[a]=b;//记录工作序号下的工作时间 
		while(c!=0)//c!=0说明他有前驱即入度不为0 
		{
			ee[c].push_back(a);//存储以c为起始点连接其他的顶点 
			cin>>c;
			ru[a]++;//入度++ 
		}
	}
	topo_sort();
	cout<<ans<<endl;
	return 0;
}
```

> 
>
> 模板：[拓扑排序](http://oj.hzjingma.com/p/36?view=classic)

[可达性统计](http://oj.hzjingma.com/p/2049?view=classic)

> 可达性统计，拓扑排序的变种问题，具体思路就是拓扑排序一下，反向遍历每个排好序的节点，反向相加，需要用到bitset位集合的数据结构



```c++
/*
这份代码可以完美诠释cin cout与scanf，printf相比到底有多慢，详见下图
*/
#include<iostream>
#include<bitset>
#include<vector>
#include<queue>
#include<cstdio>
using namespace std;
const int N=3e4+5;
bitset<N>f[N];//第一维是节点数，第二维是二进制集合
vector<int>e[N];//存储边的集合，作用跟邻接表（也可用邻接表存边）一样，邻接矩阵根本存不下...
int n,m,indu[N],topo[N],cnt;//indu[]入度的个数,topo[]存储拓扑排序的结果，cnt节点个数
void input()
{
	int u,v;
	for(int i=0;i<m;i++)
	{
		//cin>>u>>v;
		scanf("%d%d",&u,&v);
		e[u].push_back(v);//构建有向图，拓扑排序有向无环图，易错点
		indu[v]++;
	}
}
void sort_tupo()
{
	queue<int>q;
	for(int i=1;i<=n;i++)//先找到入度0的节点
	if(indu[i]==0)
	q.push(i);
	while(!q.empty())
	{
		int u=q.front();
		topo[cnt++]=u;
		q.pop();
		for(int i=0;i<e[u].size();i++)
		{
			int v=e[u][i];
			if(--indu[v]==0)
			q.push(v);
		}
	}
}
int main()
{
	//cin>>n>>m;
	scanf("%d%d",&n,&m);
	input();
	sort_tupo();
	for(int i=cnt-1;i>=0;i--)//将节点从后往前遍历
	{
		int u=topo[i];
		f[u][u]=1;
		for(int j=0;j<e[u].size();j++)
		{
			int v=e[u][j];
			f[u]|=f[v];//进行或运算其实就是进行并集
		}
	}
	for(int i=1;i<=n;i++)
	printf("%d\n",f[i].count());//输出其中1的个数
	//cout<<f[i].count()<<endl;
	return 0;
 } 
```



![image-20200507220037211](https://i.loli.net/2020/05/07/poHldfCPWh6EqzU.png)

![image-20200507220150008](https://i.loli.net/2020/05/07/kgArdVEc5u1Hei6.png)

## 最小生成树（MST）

Minimal Spanning Tree

### kruskal

描述

> 把所有边排序，依次考查每条边。若u已经和v连通，那么将(u,v)加入生成树后会产生环，不可加入。否则将(u,v)加入生成树中一定是最优的。
>
> ！怎么加入(u,v)前判断他是不是联通的？并查集

```c++
const int maxn=1e5+5;//一般边数大于顶点数
int pre[maxn];
struct edge{
    int from,to,dist;
    bool operator<(const edge&rhs)const{
		return dist<rhs.dist;
    }
}e[maxn<<1];
int find(int x)
{
    return x==pre[x]?x:pre[x]=find(pre[x]);
}
int main(){
	//input();
    sort(e,e+maxn<<1);
    for(int i=1;i<=n;i++)
        pre[i]=i;
    int sum=0,cnt=0;
    for(int i=1;i<=m;i++)//m表示边数
    {
        if(find(e[i].from)==find(e[i].to))
        {
            continue;
        }
        pre[find(e[i].from)]=find(e[i].to);//边不连通加入
         sum+=e[i].dist;//将边加入最小生成树 
        if(++cnt==n-1)//优化也就是说当加入n-1条边结束
            break;
    }
    cout<<sum<<endl;
    return 0;
}

```

例题

> 村庄建设   传送门：http://oj.hzjingma.com/contest/problem?id=129&pid=8&_pjax=%23p0
>
> 来源：蓝桥杯模拟赛

```c++
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=2e6;
struct edge{//存边 
	int from,to;
	double dist;
	bool operator<(const edge&other){//重载小于运算符 
		return dist<other.dist;
	}
}e[maxn];
int pre[maxn],x[maxn],y[maxn],h[maxn],cnt,n;
void add(int u,int v,double w)
{
	cnt++;
	e[cnt].from=u;
	e[cnt].to=v;
	e[cnt].dist=w;
}
void input()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>x[i]>>y[i]>>h[i];
	int xx,yy,hh;
	double dist;
	for(int i=1;i<=n;i++)//计算两个村庄之间的费用 
	{
		for(int j=i+1;j<=n;j++)
		{
			xx=abs(x[i]-x[j]);
			yy=abs(y[i]-y[j]);
			hh=abs(h[i]-h[j]);
			dist=sqrt(xx*xx+yy*yy)+hh*hh;
			add(i,j,dist);//将边存入 
		}
	}
}
int find(int x)//并查集 
{
	return x==pre[x]?x:pre[x]=find(pre[x]);
}
int main()
{
	double sum=0.0;
	int count=0;
	input();
	sort(e+1,e+cnt+1);//按照边从小到大排序 
//	for(int i=1;i<=cnt;i++)
//	printf("%d %d %lf\n",e[i].from,e[i].to,e[i].dist);
	for(int i=1;i<=n;i++)//初始化并查集 
	pre[i]=i;
	for(int i=1;i<=cnt;i++)//对cnt条边进行查找 
	{
		if(find(pre[e[i].from])==find(e[i].to))//两点已经连通，就不把边加入最小生成树 
		continue;
		pre[find(e[i].from)]=find(e[i].to);//加入最小生成树并且把它放到集合里 
		sum+=e[i].dist;
		if(++count==n-1)break;//优化一下 
	}
	sum=round(sum*100);//四舍五入 
	sum/=100;
	printf("%0.2lf\n",sum);
	return 0;
 } 
```

# 组合数

## 卡特兰数

> 卡特兰数是组合数学中的一种著名数列，通常用如下通项式表示(为了不与组合数C冲突，本文用f表示卡特兰数

$$
f(n)=\frac{C2n^n }{n+1 }
$$



### 应用

给定N个节点，能构成Catalan(N)种形状不同的二叉树。

> 思路：直接用公式计算f（n）即可
>
> 证明过程：[传送门](https://blog.csdn.net/adminabcd/article/details/46672759)

## 快速求解组合数

```c++
//求解Cn^m
typedef long long ll;
ll C(int n,int m)
{
    ll ans=1;
    if(m<n-m)m=n-m;//小优化，避免溢出
    for(int i=m+1;i<=n;i++)
        ans*=i;
    for(int i=1;i<=n-m;i++)
        ans/=i;
    return ans;
}
//对于Cn^m=n!/((n-m!)*m!),第一个循环做到的是ans=n!/m!，m应该越大越好，避免溢出，第二个循环做的是ans/(n-m)!
```

```c++
//递归法,很容易溢出 n=21,m=1就会溢出，不过是中间溢出超过int类型了
ll factorial(int n)
{
    ll ans=1;
    for(int i=1;i<=n;i++)
        ans*=i;
    return ans;
}
ll C(int n,int m)
{
    return factorial(n)/(factorial(m)*factorial(n-m))
}
```

# c++

## 迭代器

```c++
vector<string>::iterator it;
```



## auto&a和auto a区别

```c++
char a[]={'h','e','l','l','o'};
for(auto &x:a)
{
    x=toupper(x);
    cout<<x;
}//数组值会被修改
for(auto x:a)
{
     x=toupper(x);
    cout<<x;
}//数组值不会被修改
```



## assert断言

```c++
#include<cassert>
using namespace std;
int main()
{
    int a=5;
    assert(a==5);
    cout<<a<<endl;
    return 0;
}
//assert作用其实就是当结果和我们断言不一样的时候回报错，帮助我们debug
```

## unique函数

```c++
int main()
{
    vector<int>arr;
	arr.push_back(2);
	arr.push_back(2);
	arr.push_back(2);
	arr.push_back(5);
	arr.push_back(6);
	int len=unique(arr.begin(),arr.end())-arr.begin();
	assert(len==3);
	for(int i=0;i<len;i++)
	cout<<arr[i]<<" ";
	cout<<len<<endl;
    return 0;
}
//上述实现的就是在数组有序情况下可以删除数组重复项
```

## 第k小数

```c++
#include<algorithm>
using namespace std;
int read()        
{        
    int s = 0, f = 1;        
    char ch = getchar();        
    while(!isdigit(ch)) {        
        if(ch == '-') f = -1;        
        ch = getchar();        
    }        
    while(isdigit(ch)) {        
        s = s * 10 + ch - '0';        
        ch = getchar();        
    }        
    return s * f;        
}   
int main()
{
    int t,n,k;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		//scanf("%d%d",&n,&k);
		n=read();
		k=read();
		for(int i=0;i<n;i++)
		a[i]=read();
		//scanf("%d",&a[i]);
		nth_element(a,a+k-1,a+n);
		printf("%d\n",a[k-1]); 
	}
    return 0;
}

```

## ___int128数据类型

```c++
//__int128 16字节 long long 8字节 
/*
例题：快速幂
    [](https://ac.nowcoder.com/acm/problem/23046)
       这道题用__int128可以在爆long long 条件下不会产生溢出
*/
//输入输出模板
#include <bits/stdc++.h>
using namespace std;
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
 
int main(void){
    __int128 a = read();
    __int128 b = read();
    print(a + b);
    cout<<endl;
    return 0;
}       
```

# 结构体struct

```c++
struct node{
  int x,y;
    node():x(),y(){}//无参构造
    node(int x,int y):x(x),y(y){}//有参构造
};
```

# 类class

```c++
/*
 求职题一般都是直接给类，函数式编程，本地测试如下：
*/
#include<bits/stdc++.h>
using namespace std;
    
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return string字符串
     */
    string change(string s) {
        // write code here
        string s1,s2;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='a')
                s2+='a';
            else s1+=s[i];
        }
        return s1+s2;
    }
}test;
int main()
{
	
	cout<<test.change("");
	return 0;
 } 
```

```c++
/*
注意：c++中类的成员方法中申请int类型内存空间不能超过1e6超过的话，不会报错，但是运行不出来结果，一般数据范围太大，需要定义在类的成员变量中
另外力扣评测的话，自己在申请int类型的空间时，多组数据，需要初始化的话，建议换种思路，不要用memset(vis,0,sizeof(vis)),因为评测机貌似不会执行这个过程。
*/
```

# 算法竞赛oj

zzuoj[传送门](http://acm.zzuli.edu.cn/)里边可以找到河南省acm省赛题

郑州师范oj[传送门](http://acm.hi-54.com/index.php)